<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅谈Java语法糖</title>
    <url>/2018/05/19/%E6%B5%85%E8%B0%88Java%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<hr>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>语法糖是指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，只是更方便程序员的使用和开发。通常来说，使用语法糖能提高开发效率，增加程序的可读性，从而减少程序代码出错的机会。说白了，语法糖就是对现有语法的一个封装。</p>
<p>Java作为一种与平台无关的高级语言，当然也含有语法糖，这些语法糖并不被虚拟机所支持，在编译成字节码阶段就自动转换成简单常用语法。一般来说Java中的语法糖主要有以下几种： </p>
<ul>
<li>泛型与类型擦除</li>
<li>自动装箱与拆箱</li>
<li>变长参数</li>
<li>foreach循环</li>
<li>内部类</li>
<li>枚举类</li>
</ul>
<h3 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h3><p>在JDK1.5中，Java语言引入了泛型机制，但是这种泛型机制是通过<strong>类型擦除</strong>来实现的，即Java中的泛型只在程序源代码中有效（源代码阶段提供类型检查），在编译后的字节码文件中，就已经替换为原生类型(Raw Type,也称为裸类型)了，之后自动用强制类型转换进行替代。因此，对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>是同一个类。所以Java语言中的泛型机制其实就是一颗语法糖，相较与C++、C#相比，其泛型实现实在是不那么优雅,被称为伪泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在源代码中存在泛型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    String hello = map.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上述源代码被编译为class文件后，泛型被擦除且引入强制类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap map = <span class="keyword">new</span> HashMap(); <span class="comment">//类型擦除</span></span><br><span class="line">    map.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    String hello = (String)map.get(<span class="string">&quot;hello&quot;</span>);<span class="comment">//强制转换</span></span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>因为泛型类型都变回了原生类型,当使用泛型类型做方法参数的时候，无法根据泛型来实现重载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;String&gt;list)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>编译器会拒绝进行编译。</p>
<p>从纯技术上来讲，自动装箱、拆箱与遍历循环（Foreach循环） 这些语法糖，无论是从实现上还是从思想上都不能和泛型相比，两者的难度和深度都有很大的差距。</p>
<h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><p>我们知道Java是一门面向对象的语言，在Java世界中有一句话是这么说的：“万物皆对象”。但是Java中的基本数据类型却不是对象，他们不需要进行new操作，也不能调用任何方法，这在使用的时候有诸多不便。因此Java为这些基本类型提供了包装类，并且为了使用方便，提供了自动装箱与拆箱功能。自动装箱与拆箱在使用的过程中，其实是一个语法糖，内部还是调用了相应的函数进行转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过编译后，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = Integer.valueOf(<span class="number">1</span>); <span class="comment">// 自动装箱</span></span><br><span class="line">    <span class="keyword">byte</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = a.intValue() + b;<span class="comment">//自动拆箱</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>鉴于包装类的”==”运算在不遇到算术运算的情况下不会自动拆箱，以及它们的equals()方法不处理数据转型的关系，建议尽量少用自动装箱与拆箱</strong></p>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><p>所谓变长参数，就是方法可以接受长度不定确定的参数。变长参数特性是在JDK1.5中引入的，使用变长参数有两个条件，一是变长的那一部分参数具有相同的类型，二是变长参数必须位于方法参数列表的最后面。变长参数同样是Java中的语法糖，其内部实现是Java数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String str : args)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为class文件后如下，从中可以很明显的看出变长参数内部是通过数组实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Varargs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Varargs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String[] var1 = args;</span><br><span class="line">        <span class="keyword">int</span> var2 = args.length;</span><br><span class="line">        <span class="comment">//foreach循环的数组实现方式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            String str = var1[var3];</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//变长参数转换为数组</span></span><br><span class="line">        print(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h3><p>foreach循环的对象要么是一个数组，要么实现了Iterable接口。这个语法糖主要用来对数组或者集合进行遍历，<strong>其在循环过程中不能外部改变集合的大小</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] params = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">//循环对象为数组</span></span><br><span class="line">    <span class="keyword">for</span>(String str : params)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; lists = Arrays.asList(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="comment">//循环对象实现Iterable接口</span></span><br><span class="line">    <span class="keyword">for</span>(String str : lists)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的class文件为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   String[] params = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">   String[] lists = params;</span><br><span class="line">   <span class="keyword">int</span> var3 = params.length;</span><br><span class="line">   <span class="comment">//数组形式的增强for退化为普通for</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> str = <span class="number">0</span>; str &lt; var3; ++str) &#123;</span><br><span class="line">       String str1 = lists[str];</span><br><span class="line">       System.out.println(str1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List var6 = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;);</span><br><span class="line">   Iterator var7 = var6.iterator();</span><br><span class="line">   <span class="comment">//实现Iterable接口的增强for使用iterator接口进行遍历</span></span><br><span class="line">   <span class="keyword">while</span>(var7.hasNext()) &#123;</span><br><span class="line">       String var8 = (String)var7.next();</span><br><span class="line">       System.out.println(var8);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>Java语言中之所以引入内部类，是因为有些时候一个类只在另一个类中有用，我们不想让其在另外一个地方被使用。内部类之所以是语法糖，是因为其只是一个编译时的概念，一旦编译完成，编译器就会为内部类生成一个单独的class文件，名为outer$innter.class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javac编译后，生成两个class文件Outer.class和Outer$Inner.class，其中Outer$Inner.class的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    Outer$Inner(Outer var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">this</span>$<span class="number">0</span> = var1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类分为四种：成员内部类、局部内部类、匿名内部类、静态内部类(不会持有外部内的引用)，每一种都有其用法，这里就不介绍了。</p>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>枚举类型就是一些具有相同特性的类常量。java中类的定义使用class，枚举类的定义使用enum。在Java的字节码结构中，其实并没有枚举类型，枚举类型只是一个语法糖，在编译完成后被编译成一个普通的类。这个类继承java.lang.Enum，并被final关键字修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    APPLE,ORINGE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用jad对编译后的class文件进行反编译后得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承java.lang.Enum并声明为final</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Fruit[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Fruit[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Fruit)Enum.valueOf(Fruit, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Fruit</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举类型常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit APPLE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit ORANGE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit $VALUES[];<span class="comment">//使用数组进行维护</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        APPLE = <span class="keyword">new</span> Fruit(<span class="string">&quot;APPLE&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        ORANGE = <span class="keyword">new</span> Fruit(<span class="string">&quot;ORANGE&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Fruit[] &#123;</span><br><span class="line">            APPLE, ORANGE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它语法糖"><a href="#其它语法糖" class="headerlink" title="其它语法糖"></a>其它语法糖</h3><p>条件编译、断言语句、对枚举和字符串的switch支持、在try语句中定义和关闭资源。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>事件分发拦截机制</title>
    <url>/2017/03/21/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%8B%A6%E6%88%AA%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<hr>
<h2 id="MotionEvent-点击事件"><a href="#MotionEvent-点击事件" class="headerlink" title="MotionEvent-点击事件"></a>MotionEvent-点击事件</h2><p>当Android系统捕获到用户的各种输入事件后，要想准确的传递到真正需要这个事件的控件就需要使用到Android中的事件拦截机制。</p>
<p>这里主要讲的是点击事件的拦截机制，首先，点击事件就是手指接触屏幕后产生的事件，Android的触摸事件封装了一个类：MotionEvent，只要重写触摸相关的方法，就得用到MotionEvent。</p>
<p>MotionEvent中封装了很多方法，比如可以用<code>event.getX()</code> 与<code>event.getY()</code>来获取坐标位置，它也包含了几种不同的Action：</p>
<ul>
<li>ACTION_DOWN：手指刚刚接触到屏幕。</li>
<li>ACTION_MOVE：手指在屏幕上移动。</li>
<li>ACTION_UP：手指离开屏幕。<a id="more"></a>

</li>
</ul>
<h2 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h2><p>所谓点击事件的分发机制，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生以后，系统需要将这个事件传递到具体的View。点击事件的分发过程需要三个重要方法完成：</p>
<ul>
<li><code>public boolean dispatchTouchEvent(MotionEvent e)</code> 用于事件的分发。如果事件传递到当前View，它就一定会被调用，返回结果受View的onTouchEvent和下级的dispatchTouchEvent影响，结果表示是否消耗当前事。</li>
<li><code>public boolean onInterceptTouchEvent(MotionEvent e)</code> 用来判断是否拦截该事件，在上一方法中被调用，返回结果表示是否消耗当前事件。</li>
<li><code>public boolean onTouchEvent(MotionEvent e)</code> 在第一个方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件。</li>
</ul>
<p>下面这段伪代码表示了它们的关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> booean <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(onInterceptTouchEvent(e))&#123;</span><br><span class="line">     consume = onTonchEvent(e);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     consume = child.dispatchTouchEvent(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>对于一个根ViewGroup，点击事件产生后，首先就会传递给它，就会调用它的dispatchTouchEvent方法，如果这个ViewGroup拦截该事件，即onInterceptTouchEvent返回true，事件就会交给这个ViewGroup处理，如果不拦截该事件，即onInterceptTouchEvent返回false，事件就会传递到它的子元素，接着调用子元素的dispatchTouchEvent，如此反复知道最终被处理，不过，如果View的onTouchEvent返回false，那么它的父容器的onTouchEvent会被调用，例如在在Activity中一个点击事件产生后，它的传递顺序为:Activity-&gt;Windows-&gt;View,如果所有的元素都不处理这个事件，那么这个事件将会交给Activity的onTouchEvent方法处理，这就像公司里，上司交一项任务给你部长，部长再交给你，而你不会，就只能交给你部长处理，部长也不会，就只能传到上司那里了。</p>
<p>当View需要处理事件时，如果设置了OnTouchListener，那么OnTouchListener中的onTouch方法就会被调用，如果返回true那么onTouchEvent方法就不会被调用了。所以：View设置的onTouchListener的优先级最高，View的OnClickListener是在onTouchEvent中设置的，那么可以说OnClickListener的优先级最低。</p>
<h2 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h2><ol>
<li>一个View一旦决定拦截，那么一个事件序列都会交给他处理，并且它的onInterceptTouchEvent不会再被调用。</li>
<li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列中的其他事件都不会交给它处理，事件将交给它的父元素处理。</li>
<li>ViewGroup默认不拦截任何事件，ViewGroup的onInterceptTouchEvent方法默认返回false。</li>
<li>View没有onInterceptTouchEvent方法,一旦有点击事件传递给它,它的onTouchEvent方法就会被调用。</li>
<li>View的onTouchEvent默认都会消耗事件(返回true),除非它是不可点击的(clickable和longClickable同时为false)。View的longClickable属性默认都为false,clickable属性根据不同的View有不同的默认值。</li>
<li>onClick会方法的前提是当前View是可点击的,并且它收到了down和up的事件。</li>
<li>事件传递是由外到内的，即事件总是先传递到父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的分发过程，但是ACTION_DOWN事件除外。</li>
</ol>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ImageView图片自适应</title>
    <url>/2017/04/21/Android-ImageView%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94/</url>
    <content><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目中使用Picasso加载图片，结果发现后台给的图片太小，无法填充ImageView，在Picasso加载图片中加上fit()后图片直接不显示了，便想到前面图片太大的解决办法–给ImageView设置自适应，直接加上:<code>android:adjustViewBounds=&quot;true&quot;</code>就行了。</p>
<h2 id="ImageView属性说明"><a href="#ImageView属性说明" class="headerlink" title="ImageView属性说明"></a>ImageView属性说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:adjustViewBounds</span><br></pre></td></tr></table></figure>
<p>是否保持宽高比，是否调整ImageView的界限来保持图像纵横比不变。（可以用来网络上下载下来的图片自适应）</p>
<a id="more"></a>

<p>XML定义里的<code>android:adjustViewBounds=&quot;true&quot;</code>会将这个ImageView的scaleType设为fitCenter。不过这个fitCenter会被后面定义的scaleType属性覆盖（如果定义了的话），除非在Java代码里再次显示调用<code>setAdjustViewBounds(true)</code>。</p>
<p>它的效果还根据layout_width与layout_height的不同而不同：</p>
<ol>
<li><p>layout_width和layout_height都是定值，那么设置adjustViewBounds是没有效果的，ImageView将是设置的宽高。</p>
</li>
<li><p>layout_width和layout_height都是wrap_content，那么设置adjustViewBounds也是没有意义的，用因为ImageView将会始终与图片拥有相同的宽高比。</p>
</li>
<li><p>两者中一个是定值或者match_content，一个是wrap_content，比如layout_width=”200px” layout_height=”wrap_content”时，ImageView的宽将始终是200px，而高则分两种情况：</p>
<ul>
<li>图片的宽度小于200px时，layout_height将与图片的高相同，图片不会缩放，完整显示在ImageView中，ImageView高度与图片实际高度相同。图片没有占满ImageView，ImageView横向上有空白。</li>
<li>图片的宽度大于或等于200px时，此时ImageView的宽高比与图片相同，因此ImageView的layout_height值为：200除以图片的宽高比。比如图片是500X500的，那么layout_height是200/1。图片将保持宽高比缩放，完整显示在ImageView中，并且完全占满ImageView。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android:scaleType</span><br></pre></td></tr></table></figure>
<p>设置图片的填充方式。</p>
<p>ImageView的scaleType的属性有好几种，分别是matrix（默认）、center、centerCrop、centerInside、fitCenter、fitEnd、fitStart、fitXY.</p>
<ul>
<li>matrix: 不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分直接剪裁。</li>
<li>center: 保持原图的大小，显示在ImageView的中心，原图超过ImageView的部分剪裁。</li>
<li>centerCrop: 等比例放大原图，将原图显示在ImageView的中心，直到填满ImageView位置，超出部分剪裁。</li>
<li>centerInside: 将图片的内容完整居中显示，当原图宽高小于或等于ImageView的宽高时，按原图大小居中显示；反之将原图等比例缩放至ImageView的宽高并居中显示。</li>
<li>fitCenter: 按比例拉伸图片，拉伸后图片的宽度为ImageView的宽度，且显示在ImageView的中间。</li>
<li>fitEnd: 按比例拉伸图片，拉伸后图片的宽度为ImageView的宽度，且显示在ImageView的下边。</li>
<li>fitStart: 按比例拉伸图片，拉伸后图片的宽度为ImageView的宽度，且显示在ImageView的上边。</li>
<li>fitXY: 拉伸图片（不按比例）以填充ImageView的宽高。</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity的生命周期和启动模式</title>
    <url>/2016/10/11/Activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h1 id="一-、Activity的生命周期"><a href="#一-、Activity的生命周期" class="headerlink" title="一 、Activity的生命周期"></a>一 、Activity的生命周期</h1><h2 id="1-典型情况下的生命周期分析如下："><a href="#1-典型情况下的生命周期分析如下：" class="headerlink" title="1.典型情况下的生命周期分析如下："></a>1.典型情况下的生命周期分析如下：</h2><p><img src="http://autism-tl.cn/picture/activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Activity生命周期"><br><code>onCreate()</code> Activity正在被创建，可以做些初始化工作。</p>
<a id="more"></a>

<p><code>onRestart()</code> Activity正在重新启动，一般，当当前Activity从不可见重新可见时调用。</p>
<p><code>onStart()</code> Activity正在启动，Activity可见但是还没出现在前台，还无法与用户交互。</p>
<p><code>onResume()</code> Activity可见，并且出现在前台开始活动。</p>
<p><code>onPause</code> 表示Activity正在停止，正常情况下，紧接着<code>onStop</code> 会被调用，但如果在这个时候快速回到原Activity，<code>onResume()</code> 将被调用。 此处可以做一些存储数据、停止动画等工作，但不能进行太耗时的操作，不然将会影响新Activity的显示（<code>onPause()</code>必须先执行完，新Activity的<code>onResume()</code>才会执行）。 </p>
<p><code>0nStop()</code> Activity即将停止，可以做一些稍微重量级的回收工作，同样不能太耗时。</p>
<p><code>onDestroy()</code> Activity即将被销毁，可以进行最终的回收工作与资源释放。</p>
<p><strong>注意</strong></p>
<ul>
<li>新Activity是透明主题时，旧Activity不会走onStop。</li>
<li>Activity切换时，旧Activity的onPause会先执行，然后才会启动新的         Activity。</li>
<li><code>onStart()</code>和<code>onStop()</code>、<code>onPause()</code>和<code>onResume()</code>的区别：这两个配对分别代表不同的意义，onStart与onStop是从Activity是否可见这个角度调用的，onResume和onPause是从Activity是否显示在前台这个角度来回调的，在实际使用没其他明显区别。</li>
</ul>
<h2 id="2-异常情况下的生命周期分析"><a href="#2-异常情况下的生命周期分析" class="headerlink" title="2.异常情况下的生命周期分析"></a>2.异常情况下的生命周期分析</h2><p>除了典型生命周期外，还有一些异常情况，比如当资源相关的系统配置发送改变以及系统内存不足的时候，Activity就可能被杀死。</p>
<h3 id="1-资源相关的系统配置发送改变导致Activity被杀死并重新创建"><a href="#1-资源相关的系统配置发送改变导致Activity被杀死并重新创建" class="headerlink" title="1. 资源相关的系统配置发送改变导致Activity被杀死并重新创建"></a>1. 资源相关的系统配置发送改变导致Activity被杀死并重新创建</h3><p>根据安卓系统的资源加载机制，我们为了兼容不同的设备，一张图片需要准备不同大小精度的图片，系统会根据当前设备的情况去加载适合的Resources资源，这就导致横屏和竖屏会加载到两张不同的图片，如果突然旋转屏幕，系统配置发送了改变，在默认情况下，Activity会被销毁重建，当然我们也可以阻止系统重建我们的Activity。</p>
<p>默认情况下，当系统配置发送改变后，Activity会调用到<code>onDestroy</code>，同时由于Activity在异常情况下终止，系统会在<code>onStop</code>之前调用<code>onSaveInstanceState</code>来保存当前Activity的状态。当Activity被重建后，系统会在<code>onStart</code>之后调用<code>onRestoreInstanceState</code>,并且把<code>onSaveInstanceState</code>方法保存的Bundle对象作为参数传递给onRestoreInstanceState和onCreate方法，用来取出之前的数据并恢复。</p>
<p>系统默认为我们做了一定的恢复工作，比如恢复Activity的视图结构（文本框输入的数据，ListView滚动的位置等，每个View也有<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>,看看不同View的具体实现就能知道系统自动为它们恢复了哪些数据）。保存和恢复View层次结构用的是典型的委托思想，顶层容器一般是DecorView。</p>
<h3 id="2-资源内存不足导致低优先级的Activity被杀死"><a href="#2-资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="2. 资源内存不足导致低优先级的Activity被杀死"></a>2. 资源内存不足导致低优先级的Activity被杀死</h3><p><strong>优先级</strong></p>
<ul>
<li>前台Activity–正在交互的Activity，优先级最高，</li>
<li>可见但非前台Activity</li>
<li>后台Activity–执行了onStop的Activity，优先级最低</li>
</ul>
<p>当系统内存不足时，会按照上述优先级去杀死目标Activity所在的进程，并在后续通过<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>存储和恢复数据。一些后台工作不适合脱离四大组件而独自运行在后台中，因为一个进程中如果没有四大组件在运行很快会被系统杀死，比较好的方法是将后台工作放入Service中从而保证进程有一定的优先级。</p>
<p><strong>给Activity指定configChanges属性可以防止系统默认销毁重建（系统会调用Activity的onConfigurationChanged方法，我们能在这个方法做一些自己的特殊处理）。</strong></p>
<h1 id="二、Activity的启动模式"><a href="#二、Activity的启动模式" class="headerlink" title="二、Activity的启动模式"></a>二、Activity的启动模式</h1><ol>
<li>standard:标准模式，默认模式。每次启动一个Activity就会创建一个新的实例。（使用ApplicationContext去启动standard模式Activity就会报错。因为sandard模式的Activity会默认进入启动它所属的任务栈，但是由于非Activity类型的Context（如ApplicationContext）没有所谓的任务栈 就出错了。）</li>
<li>singleTop：栈顶复用模式。如果新Activity已经位于任务栈的栈顶，就不会重新创建，同时回调它的onNewIntent方法。</li>
<li>singleTask：栈内复用模式。 单实例模式，只要Activity在一个任务栈中存在，那么就不会重新创建，系统将回调onNewIntent方法。如果不存在A想要的任务栈就会重新创建一个任务栈 并将A实例化后放入栈中（默认具有clearTop的效果）。</li>
<li>singleInstance：单实例模式。 具有此模式的Activity只能单独位于一个任务栈中。</li>
</ol>
<p><strong>在Intent中设置标记位同样也能设置启动模式，但会有些许的差别。</strong></p>
<h1 id="三、IntentFilter的匹配规则"><a href="#三、IntentFilter的匹配规则" class="headerlink" title="三、IntentFilter的匹配规则"></a>三、IntentFilter的匹配规则</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activity</span><br><span class="line"> android:name&#x3D;&quot;com.gaop.MainActivity&quot;</span><br><span class="line"> android:configChanges&#x3D;&quot;screenLayout&quot;&#x2F;&#x2F;设置在某些情况下不重新创建Activity</span><br><span class="line"> android:lable&#x3D;&quot;@string&#x2F;app_name&quot;</span><br><span class="line"> android:launchMode&#x3D;&quot;singleTask&quot;</span><br><span class="line"> android:taskAffinity&#x3D;&quot;com.gaop.task1&quot;&#x2F;&#x2F;设置任务栈</span><br><span class="line"> &lt;intent-filter&gt;</span><br><span class="line">  &lt;action android:name&#x3D;&quot;com.tl.c&quot;&#x2F;&gt;</span><br><span class="line">  &lt;action android:name&#x3D;&quot;com.tl.d&quot;&#x2F;&gt;</span><br><span class="line">  &lt;category android:name&#x3D;&quot;com.tl.category.c&quot;&#x2F;&gt;</span><br><span class="line">  &lt;category android:name&#x3D;&quot;com.tl.category.d&quot;&#x2F;&gt;</span><br><span class="line">  &lt;category android:name&#x3D;&quot;android.intent.category.DEFAULT&quot;&#x2F;&gt;</span><br><span class="line">  &lt;data android:mimeType&#x3D;&quot;text&#x2F;plain&quot;&#x2F;&gt;</span><br><span class="line"> &lt;&#x2F;intent-filter&gt;</span><br><span class="line">&lt;&#x2F;activity&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>action匹配规则 要Intent中的action能够与过滤规则中的任何一个相同即可匹配成功，如果没有指定action，匹配失败。</li>
<li>category匹配规则 Intent中一旦出现category就必须每个category与过滤规则中的其中一个相同，Intent中没有category也会匹配成功（系统会自动添加一个默认category）。</li>
<li>data的匹配规则 data由mimeType（媒体类型，如 image/jpeg ）与URL组成。 规则中只有mimeType时，Intent必须是指定的mimeType。 有多组data规则时，匹配其中一组即可。</li>
</ol>
<p><strong>采用隐式方式启动Activity时，可以用PackageManager的resolveActivity方法或者Intent的resolveActivity方法判断是否有Activity匹配我们的隐式Intent。</strong></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的线程池</title>
    <url>/2017/06/08/Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用线程池能给我们带来很多好处，线程池的优点可以概括为以下三点：</p>
<ul>
<li>重用线程池中的线程，减少创建和销毁线程的性能开销。</li>
<li>有效控制线程池的最大并发数，避免因为大量的线程之间因为抢夺系统资源造成阻塞。</li>
<li>能对线程进行简单的管理，并提供定时执行以及指定时间间隔循环执行等。</li>
</ul>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>Android中的线程池概念来源于Java中的Executor,Executor是一个接口,真正的线程池实现为ThreadPoolExecutor,他提供一系列参数来配置线程池。其构造方法为：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> corePoolSize,   //核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> maximumPoolSize,   //最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">long</span> keepAliveTime, //超时时长</span></span></span><br><span class="line"><span class="function"><span class="params">    TimeUnit unit,  //指定时间单位，枚举类型</span></span></span><br><span class="line"><span class="function"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue,  //任务队列</span></span></span><br><span class="line"><span class="function"><span class="params">    ThreadFactory threadFactory//线程工厂接口</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span></span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<ul>
<li>corePoolSize :核心线程数，默认核心线程会在线程中一直存活，即使闲置。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时，闲置的核心线程在等待新任务时会有超时策略，时间由keepAliveTime决定，超时将被终止。</li>
<li>maximumPoolSize :最大线程数，活动线程数量超过它，后续任务就会被阻塞。</li>
<li>keepAliveTime :非核心线程超时时长，超过便被回收。当allowCoreThreadTimeOut属性为true时，同样作用于核心线程。</li>
<li>unit :keepAliveTime的单位，枚举类型，常用有 TimeUnit.MILLISECONDS(ms) TimeUnit.SECONDS(s) TimeUnit.MINUTES(min) 等等。</li>
<li>workQueue :任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</li>
<li>threadFactory :线程工厂，只有一个new Thread(Runnable r)方法，可为线程池创建新线程。</li>
</ul>
<p><strong>ThreadPoolExecutor执行任务规则：</strong></p>
<ol>
<li>线程数量&lt;核心线程数量 启动一个核心线程执行任务。</li>
<li>线程数量&gt;=核心线程数量，将任务插入任务队列等待执行（任务队列未满）。</li>
<li>当任务队列满了时，立即启动一个非核心线程执行任务(线程数量未达到规定的最大线程数)。</li>
<li>线程数量达到线程池规定最大值，拒绝执行，抛出异常。</li>
</ol>
<h2 id="线程池分类"><a href="#线程池分类" class="headerlink" title="线程池分类"></a>线程池分类</h2><p>根据不同的参数，Android中设计了四类不同功能特性的线程池，它们直接或者间接的通过设置ThreadPoolExecutor实现。它们分别为：FixedThreadPool、CachedThreadPool、ScheduledThreadPool、SingleThreadExecutor。</p>
<p><strong>1. FixedThreadPool</strong><br>创建:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;  </span><br><span class="line">Executors.newFixThreadPool(<span class="number">5</span>).execute(r);</span><br></pre></td></tr></table></figure>
<p>说明: 从参数上可以看出，它只有核心线程，数量固定，而且不会回收(除非线程池被关闭了)，也没有超时限制。所以，当所有核心线程都处于活动状态时，新任务就处于等待状态，直到有线程空闲。这些特性使得FixedThreadPool能够快速响应外界请求。另外它的任务队列也是没有大小限制的.</p>
<p><strong>2. CachedThreadPool</strong><br>创建:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit. SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());  </span><br><span class="line">&#125;  </span><br><span class="line">Executors.newCachedThreadPool().execute(r);</span><br></pre></td></tr></table></figure>
<p>说明: CachedThreadPool中没有核心线程，线程最大数为Integer.MAX_VALUE(很大的数)，意味着线程数量没有限制。所以当线程池中的线程都处于活动状态时，会为新任务创建新线程，否则就利用空闲线程（60s空闲时间，过了就会被回收，所以线程池中有0个线程的可能）处理任务。任务队列SynchronousQueue(非常特殊的队列,很多情况下可以理解为无法存储元素)相当于一个空集合，任何任务都会被立即执行。这类线程池比较适合执行大量的耗时较少的任务。</p>
<p><strong>3. ScheduledThreadPool</strong><br>创建:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>&#123;  </span><br><span class="line"><span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> DelayedQueue ());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//2s后执行r任务</span></span><br><span class="line">Executors. newScheduledThreadPool(<span class="number">5</span>).scheduleAtFixedRate(r, <span class="number">2000</span>, TimeUnit.MILLISECONDS);  </span><br><span class="line"><span class="comment">//延迟10ms后，每隔2s执行一次r任务</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">5</span>).scheduleAtFixedRate(r, <span class="number">10</span>, <span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>
<p>说明: 核心线程数固定，非核心线程（闲置将被立即回收）数没有限制。ScheduledThreadPool主要用于执行定时任务以及有固定周期的重复任务。</p>
<p><strong>4. SingeleThreadExecutor</strong><br>创建:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadPool</span> <span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService ( <span class="keyword">new</span> ThreadPoolExecutor (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, TimeUnit. MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()) );  </span><br><span class="line">&#125;  </span><br><span class="line">Executors.newSingleThreadPool().execute(r);</span><br></pre></td></tr></table></figure>
<p>说明：这种线程池只有一个核心线程，该线程池的意义在于统一所有的外界任务到同一线程中按顺序执行。因此这些任务之间不需要处理线程同步的问题。</p>
<h2 id="AsyncTask中的线程池"><a href="#AsyncTask中的线程池" class="headerlink" title="AsyncTask中的线程池"></a>AsyncTask中的线程池</h2><p>AsyncTask中有两个线程池(SerialExecutor和THREAD_POOL_EXECUTOR)和一个Handle(InternalHandle),其中线程池SerialExecutor用于任务的排队,HREAD_POOL_EXECUTOR用于真正执行任务,InternalHandle用于将执行环境从线程池切换到主线程。</p>
<p>AsyncTask中的线程池THREAD_POOL_EXECUTOR配置规格:</p>
<ul>
<li>核心线程数等于CPU核心数 +1</li>
<li>线程池最大线程数为CPU核心数的2倍 +1</li>
<li>核心线程无超时机制,非核心线程闲置超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的Window与WindowManager</title>
    <url>/2017/05/20/Android%E4%B8%AD%E7%9A%84Window%E4%B8%8EWindowManager/</url>
    <content><![CDATA[<hr>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>Android中的所有视图，不管是Activity、Dialog还是Toast都是通过Window来呈现的，它们的视图都是附加在Window上面的，Window实际是View的直接管理者。<br>Window是一个抽象类，它的具体实现是PhoneWindow，WindowManager是外界访问Window的入口，Window的具体实现位于WindowManagerService中，WindowManger与WindowMangerService的交互其实是个IPC过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mFloatingButton=<span class="keyword">new</span> Button(<span class="keyword">this</span>);</span><br><span class="line">mFloatingButton.setText(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">mLayoutParams=<span class="keyword">new</span> WindowManger.LayoutParams(</span><br><span class="line">            LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">            PixlFormat.TRANSAPARENT);</span><br><span class="line">mLayoutParams.flags=LayoutParams.FLAG_NOT_TOUCH_MODAL|LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">                    |LaoutParams.FLAG_SHOW_WHEN_FOCUSABLE;</span><br><span class="line">mLayoutParams.x=<span class="number">100</span>;</span><br><span class="line">mLayoutParams.y=<span class="number">200</span>;</span><br><span class="line">mWindowManger.addView(mFloatingButton,mLayoutParams);</span><br></pre></td></tr></table></figure>
<p>上述代码可以将一个Button添加到屏幕坐标为(100,200)的位置上。</p>
<a id="more"></a>

<p><strong>Flags表示Window的属性，以下为几个常见的属性：</strong></p>
<ul>
<li>FLAG_NOT_TOUCH_MODAL 表示不需要获取焦点，也不需要接收各种输入，最终事件直接传递给下层具有焦点的Window。</li>
<li>FLAG_NOT_FOCUSABLE：在此Window外的区域单击事件传递到底层Window中。区域内的单击事件则自己处理，这个一般都要设置，否则其他的Window将无法收到单击事件。</li>
<li>FLAG_SHOW_WHEN_LOCKED：开启可以让Window显示在锁屏界面上。</li>
</ul>
<p><strong>Type表示Window的类型，类型分为</strong>：应用Window（Activity）、子Window（不能单独存在，必须依附在父Window中，Dialog等）、系统Window（需声明权限才能创建，Toast等）。</p>
<p>Window中存在分层，层级大会覆盖在层级小的上面，应用Window的层级一般为1-99，子Window的层级一般为1000-1999，系统Window为2000-2999。</p>
<h2 id="Window内部机制"><a href="#Window内部机制" class="headerlink" title="Window内部机制"></a>Window内部机制</h2><p>Window是一个抽象的概念，一个Window对应一个View和一个ViewRootImpl,Window和View通过ViewRootImpl来建立联系，所以Window并不实际存在，它是以View存在的。<br>Window的操作需要通过WindowManager，WindowManager常用的只有三个方法，即添加/更新/删除View。<br>WindowManager是一个接口，它的实现类是WindowManagerImpl。WindowManagerImpl也并没有直接实现三大操作，而是委托给WindowManagerGlobal。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WindowManger继承了这个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="添加Window"><a href="#添加Window" class="headerlink" title="添加Window"></a>添加Window</h3><p><strong>addView的实现分为以下几步：</strong><br>1.检查参数是否合法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;display must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line">        <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there&#x27;s no parent and we&#x27;re running on L or above (or in the</span></span><br><span class="line">            <span class="comment">// system context), assume we want hardware acceleration.</span></span><br><span class="line">            <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">            <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; context.getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建ViewRootImpl并将View添加到列表中。<br>WindowMangerGlobal内部存在如下几个列表：</p>
<ul>
<li>ArrayList mViews; 所有Window对应的View</li>
<li>ArrayList mRoots; 所有Window对应iewRootImpl</li>
<li>ArrayList mParams; 所有Window对应LayoutParams</li>
<li>ArraySet mDyingViews; 调用removeView但是删除还未完成的Window对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">view.setLayoutParams(wparams);</span><br><span class="line">mViews.add(view);</span><br><span class="line">mRoots.add(root);</span><br><span class="line">mParams.add(wparams);</span><br></pre></td></tr></table></figure>
<p>3.通过ViewRootImpl来更新界面并完成window的添加过程 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure>
<p>setView内部会通过requestLayout异步刷新，最后通过IPC操作调用WindowManagerService实现Window添加。</p>
<h3 id="删除Window"><a href="#删除Window" class="headerlink" title="删除Window"></a>删除Window</h3><p>同Window的添加一样，都是最终通过WindowManagerGlobal实现，下面是其中的removeView：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">            View curView = mRoots.get(index).getView();</span><br><span class="line">            removeViewLocked(index, immediate);</span><br><span class="line">            <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Calling with view &quot;</span> + view</span><br><span class="line">                    + <span class="string">&quot; but the ViewAncestor is attached to &quot;</span> + curView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里首先调用findViewLocked来查找删除view的索引，这个过程就是建立数组遍历。然后再调用removeViewLocked来做进一步的删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);</span><br><span class="line">        View view = root.getView();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">            <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">                mDyingViews.add(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>真正删除操作是viewRootImpl来完成的。windowManager提供了两种删除接口，removeViewImmediate，removeView。它们分别表示异步删除和同步删除。具体的删除操作由ViewRootImpl的die来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">            doDie();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Attempting to destroy the window while drawing!\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;  window=&quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;, title=&quot;</span> + mWindowAttributes.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由上可知如果是removeViewImmediate，立即调用doDie，如果是removeView，用handler发送消息，ViewRootImpl中的Handler会处理消息并调用doDie。</p>
<p><strong>最终删除主要做四件事：</strong></p>
<ol>
<li>垃圾回收相关工作，比如清数据，回调等。</li>
<li>通过Session的remove方法删除Window,最终通过IPC调用WindowManagerService的removeWindow。</li>
<li>调用dispathDetachedFromWindow，在内部会调用onDetachedFromWindow()和onDetachedFromWindowInternal()。当view移除时会调用onDetachedFromWindow，它用于作一些资源回收。</li>
<li>通过doRemoveView刷新数据，删除相关数据，如在mRoot，mDyingViews等中删除对象。</li>
</ol>
<h3 id="更新Window"><a href="#更新Window" class="headerlink" title="更新Window"></a>更新Window</h3><p>看下WindowManagerGlobal中的updateViewLayout。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;view must not be null&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"> </span><br><span class="line">       view.setLayoutParams(wparams);</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">           <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">           ViewRootImpl root = mRoots.get(index);</span><br><span class="line">           mParams.remove(index);</span><br><span class="line">           mParams.add(index, wparams);</span><br><span class="line">           root.setLayoutParams(wparams, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>通过viewRootImpl的setLayoutParams更新ViewRootImpl的LayoutParams,接着scheduleTraversals对View重新布局，包括测量，布局，重绘，此外它还会通过WindowSession来更新Window。这个过程通过IPC由WindowManagerService实现。</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA垃圾收集</title>
    <url>/2017/04/12/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<hr>
<p>Java虚拟机的内存区域中，程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭；栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作，每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这三个区域的内存分配和回收都具有确定性。垃圾回收重点关注的是堆和方法区部分的内存。</p>
<p>Java提供finalize()方法，垃圾回收器准备释放内存的时候，会先调用finalize()。</p>
<ul>
<li>对象不一定会被回收。</li>
<li>垃圾回收不是析构函数。</li>
<li>垃圾回收只与内存有关。</li>
<li>垃圾回收和finalize()都是靠不住的，只要JVM还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收。<a id="more"></a>

</li>
</ul>
<h1 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h1><p>给对象添加一个引用计数器，一旦有一个地方引用它时，计数器加1，引用失效时，减1，任何引用计数为0的随时都是可能被回收的。<br>引用计数算法实现简单，判定效率也高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理,但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。</p>
<h1 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h1><p>通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连，则证明该对象是不可用的,垃圾收集器将回收其所占的内存。<br>主流的商用程序语言C#、java和Lisp都使用根搜素算法进行内存管理。<br>Java语言中以下可作为GC Roots：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中JNI的引用的对象</li>
</ul>
<h1 id="Java中常用的垃圾收集算法"><a href="#Java中常用的垃圾收集算法" class="headerlink" title="Java中常用的垃圾收集算法"></a>Java中常用的垃圾收集算法</h1><h2 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h2><p>最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收掉所有被标记的对象。</p>
<p>标记-清除算法的缺点有两个：首先，效率问题，标记和清除效率都不高。其次，标记清除之后会产生大量的不连续的内存碎片，空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h2 id="复制算法："><a href="#复制算法：" class="headerlink" title="复制算法："></a>复制算法：</h2><p>将可用内存按容量分成大小相等的两块，每次只使用其中一块，当这块内存使用完了，就将还存活的对象复制到另一块内存上去，然后把使用过的内存空间一次清理掉。这样使得每次都是对其中一块内存进行回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>复制算法的缺点显而易见，可使用的内存降为原来一半。</p>
<h2 id="标记-整理算法："><a href="#标记-整理算法：" class="headerlink" title="标记-整理算法："></a>标记-整理算法：</h2><p>标记-整理算法在标记-清除算法基础上做了改进，标记阶段是相同的标记出所有需要回收的对象，在标记完成之后不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，在移动过程中清理掉可回收的对象，这个过程叫做整理。</p>
<p>标记-整理算法相比标记-清除算法的优点是内存被整理以后不会产生大量不连续内存碎片问题。</p>
<p>复制算法在对象存活率高的情况下就要执行较多的复制操作，效率将会变低，而在对象存活率低的情况下使用标记-整理算法效率会大大提高。</p>
<h2 id="分代收集算法："><a href="#分代收集算法：" class="headerlink" title="分代收集算法："></a>分代收集算法：</h2><p>根据内存中对象的存活周期不同，将内存划分为几块，java的虚拟机中一般把内存划分为新生代和年老代，当新创建对象时一般在新生代中分配内存空间，当新生代垃圾收集器回收几次之后仍然存活的对象会被移动到年老代内存中，当大对象在新生代中无法找到足够的连续内存时也直接在年老代中创建。</p>
<p><strong>现在的Java虚拟机就联合使用了分代、复制、标记-清除和标记-整理算法</strong></p>
<h1 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h1><ul>
<li>强引用：Object o = new Object()这种引用，只要强引用存在，垃圾收集器就不会回收</li>
<li>软引用：一些还可用，但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围。通过SoftReference实现。</li>
<li>弱引用：非必须对象。比软引用更弱。只能生存到下一次垃圾回收之前，通过WeakReference实现。</li>
<li>虚引用：幽灵引用，最弱的一种引用。一个对象是否有虚引用，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是希望能在对象在被垃圾收集时得到一个系统通知。通过PhantomReference实现。</li>
</ul>
<h1 id="二次标记与finalize-方法"><a href="#二次标记与finalize-方法" class="headerlink" title="二次标记与finalize()方法"></a>二次标记与finalize()方法</h1><p>在根搜索算法中不可达的对象，将会被第一次标记并根据是否实现了finalize方法和是否调用过finalize筛选，如果这个对象认为有必要执行finalize方法，就会放入一个F-Queue的队列中执行，稍后GC将对F-Queue中的对象进行二次标记，如果对象在finalize中拯救了自己（只要重新与引用链上任何对象建立关联就行），那么二次标记后他将移出“即将回收”队列，如果没有，就离死亡不远了。不过finalize只会执行一次，下次回收时就无法拯救了。（不建议实现finalize方法）</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA内存区域与内存溢出异常</title>
    <url>/2017/03/07/JAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<hr>
<h1 id="一、概论"><a href="#一、概论" class="headerlink" title="一、概论"></a>一、概论</h1><p>java不需要程序员针对new操作去写free/delete代码，这靠的就是虚拟机的自动内存管理机制，但是一旦出现内存泄露或者溢出的情况，如果不了解虚拟机是怎么使用内存的，排查错误将成为一种异常艰难的工作。</p>
<h1 id="二、运行时数据区域"><a href="#二、运行时数据区域" class="headerlink" title="二、运行时数据区域"></a>二、运行时数据区域</h1><p>Java虚拟机在执行Java程序时会把他所管理的内存划分为几个不同的数据区域。</p>
<h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p>它是一块较小的内存空间，它的作用可以看成当前线程所执行字节码的行号指示器，在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值去选取下一条需要执行的字节码指令。</p>
<a id="more"></a>
<p>每个线程都有一个独立的程序计数器，每条线程之间的计数器互不影响，独立存储。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法,这个计数器的值则为空，此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError的区域。</p>
<h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h2><p>同样也是线程私有的，它的生命周期与线程相同，它描述的是Java方法执行的内存模型：每个方法执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成都对应着一个栈帧从虚拟机中从入栈到出栈的过程。<br>局部变量表中存放着编译器可知的各种基本数据类型、对象引用（reference类型）和returnAddress类型。<br>其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间就完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，这个方法运行期间不会改变局部变量表的大小。<br>在Java虚拟机中，这个区域规定了两种异常情况：如果请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError;如果虚拟机栈能够动态扩展，当扩展时无法申请到足够的内存时将抛出OutOfMemoryError。</p>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p>与虚拟机栈发挥的作用是非常相似的，区别是本地方法栈是为虚拟机使用到的Native方法服务，异常抛出同上。</p>
<h2 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4.Java堆"></a>4.Java堆</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，Java堆是所有线程共享的一块内存区域，在虚拟机启动的时候创建。该内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述为：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生。<br>Java堆是垃圾收集器管理的主要区域。如果从内存回收的角度看，Java堆还可以分为新生代和老年代.如果从内存分配的角度看，线程共享的Java堆还可以分为多个线程私有的分配缓存区。不过不管怎么划分，都与存放内容无关。<br>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的就行。在实现时，可以实现成固定大小的，也可以是可扩展的，不过一般的都是安装可扩展来实现的（通过-Xmx和-Xms控制）。如果堆中没有内存完成实例分配，并且堆也无法得到再扩展时，就会抛出OutOfMemoryError。</p>
<h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p>与堆一样都是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>在HotSpot虚拟机中它被称作“永久代”，因为HotSpot把GC分代收集扩展到了方法区。其他的虚拟机没有永久代的概念。<br>它和Java堆一样不需要连续的存放空间和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，一样在无法满足内存分配需求时抛出OutOfMemoryError。</p>
<h2 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6.运行时常量池"></a>6.运行时常量池</h2><p>JDK1.6之前是方法区的一部分，JDK1.7被移到堆中管理，具有动态性，用于存放编译器生成的各种字面量和符号引用。<br>运行时常量池相对与Class文件常量池的一个重要特征就是具有动态性，Java语言并不要求常量一定要在编译器产生，运行期间也可以将新的常量放入池中，这个特性被开发人员用的比较多的就是String的intern()方法。<br>同样，可能抛出OutOfMemoryError。</p>
<h1 id="三、对象访问"><a href="#三、对象访问" class="headerlink" title="三、对象访问"></a>三、对象访问</h1><p>Object obj = new Object（）；<br>在这句代码中Object obj将会反应到Java的本地变量表，作为一个reference类型数据出现，而new Object()将会反应到Java堆中，形成一块存储Object类型所有实例数据值的结构化内存。另外，在Java堆中还必须包含能查找到此对象类型数据（如父类，对象类型，接口，方法等）的地址信息，这些类型数据将存储在方法区中。<br>由于reference中只规定了一个指向对象的引用，并没有定义这个引用该如何去定位，主流的定位方法有两种：</p>
<ul>
<li>使用句柄访问方式，Java堆中划分一块内存作为句柄池，reference中存储的是对象的句柄对象，而句柄中包含了对象实例数据和类型信各自的具体地址信息。较稳定，对象移动只需改变句柄中的实例数据指针。</li>
<li>直接指针访问，reference存储的就是对象地址。速度更快。</li>
</ul>
<h1 id="四、OutOfMemoryError异常"><a href="#四、OutOfMemoryError异常" class="headerlink" title="四、OutOfMemoryError异常"></a>四、OutOfMemoryError异常</h1><h2 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1.Java堆溢出"></a>1.Java堆溢出</h2><p>在Java Debug Configuration中可以设置参数<br>-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8<br>再运行以下程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	List&lt;OOMObject&gt;  list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">			&#125;                 </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOf(Arrays.java:3210)<br>at java.util.Arrays.copyOf(Arrays.java:3181)<br>at java.util.ArrayList.grow(ArrayList.java:261)<br>at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235)<br>at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227)<br>at java.util.ArrayList.add(ArrayList.java:458)<br>at HeapOOM.main(HeapOOM.java:8)</p>
<h2 id="2-Java虚拟机栈和本地方法栈溢出"><a href="#2-Java虚拟机栈和本地方法栈溢出" class="headerlink" title="2.Java虚拟机栈和本地方法栈溢出"></a>2.Java虚拟机栈和本地方法栈溢出</h2><p>在HotSpot虚拟机中不区分虚拟机栈和本地方法栈，因此对于Hotspot虚拟机，-Xoss参数（设置本地方法栈的大小）实际上是无效的，栈容量只由-Xss参数决定。<br>-Xss228K</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackSOF</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		stackLength++;</span><br><span class="line">		stackLeak();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		StackSOF  sof=<span class="keyword">new</span> StackSOF();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">		sof.stackLeak();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;stack length:&quot;</span>+sof.stackLength);</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br>Exception in thread “main” java.lang.StackOverflowError<br>at StackSOF.stackLeak(StackSOF.java:7)<br>at StackSOF.stackLeak(StackSOF.java:7)<br>at StackSOF.stackLeak(StackSOF.java:7)<br>at StackSOF.stackLeak(StackSOF.java:7)…</p>
<h2 id="3-运行时常量池溢出"><a href="#3-运行时常量池溢出" class="headerlink" title="3.运行时常量池溢出"></a>3.运行时常量池溢出</h2><p>向运行池常量池中添加内容，最简单的做法是使用String.intern()这个Native方法，它的作用是：如果池中包含了一个等于此String对象的字符串，那么返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并返回此String对象的引用。由于常量池分配在方法区内，可以通过-XX:PermSize和-XX:MaxPermSize（在HotSpot 8.0中忽略了这两个参数）限制方法区的大小。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String源码解析</title>
    <url>/2017/02/18/String%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<h1 id="1、String类"><a href="#1、String类" class="headerlink" title="1、String类"></a>1、String类</h1><p>String为final类，所以String为不可变量，String类还实现了Serializable,Comparable,CharSequence接口。<br>Comparable接口有compareTo（String s）方法。<br>CharSequence接口有length(),charAt(int index),subSequence(int start,int end)方法。</p>
<p>String类中有一个final的char数组用来存放字符串，一个int类型的hash用来存放哈希值。</p>
<h1 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h1><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/不含参数，基本没用</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数为String类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = original.value;</span><br><span class="line">         <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数为char数组，使用Arrays.copyOf()给value复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//将char数组从offset开始的长度为length的字符复制给value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">         <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//将int数组从offset开始的长度为length的数据转型为字符复制给value</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">int</span>[] codePoints, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">         <span class="keyword">if</span> (offset &gt; codePoints.length - count) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> end = offset + count;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Pass 1: Compute precise size of char[]</span></span><br><span class="line">         <span class="keyword">int</span> n = count;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++) &#123;</span><br><span class="line">             <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">             <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (Character.isValidCodePoint(c))</span><br><span class="line">                 n++;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(Integer.toString(c));</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">// Pass 2: Allocate and fill in char[]</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">char</span>[] v = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = offset, j = <span class="number">0</span>; i &lt; end; i++, j++) &#123;</span><br><span class="line">             <span class="keyword">int</span> c = codePoints[i];</span><br><span class="line">             <span class="keyword">if</span> (Character.isBmpCodePoint(c))</span><br><span class="line">                 v[j] = (<span class="keyword">char</span>)c;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 Character.toSurrogates(c, v, j++);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.value = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> ascii[], <span class="keyword">int</span> hibyte, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查是否越界</span></span><br><span class="line">         checkBounds(ascii, offset, count);</span><br><span class="line">         <span class="keyword">char</span> value[] = <span class="keyword">new</span> <span class="keyword">char</span>[count];</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (hibyte == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">                 value[i] = (<span class="keyword">char</span>)(ascii[i + offset] &amp; <span class="number">0xff</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             hibyte &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = count; i-- &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">                 value[i] = (<span class="keyword">char</span>)(hibyte | (ascii[i + offset] &amp; <span class="number">0xff</span>));</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//从bytes数组中的offset位置开始，将长度为length的字节，以charsetName格式编码，拷贝到value</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;charsetName&quot;</span>);</span><br><span class="line">         checkBounds(bytes, offset, length);</span><br><span class="line">         <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//参数为StringBuffer（线程安全）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//参数为StringBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="3、String常用方法"><a href="#3、String常用方法" class="headerlink" title="3、String常用方法"></a>3、String常用方法</h1><p>length()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> value.length;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>isEmpty()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>equals(Object o)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//是否同一对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是否为String类型数据</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="comment">//长度是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//从后向前判断</span></span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>compareTo(String s)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">        <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">        <span class="comment">//取长度最小值</span></span><br><span class="line">        <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从前往后直到第lim个进行比较</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">            <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">     &#125;</span><br><span class="line">       <span class="comment">//相同则比较长度</span></span><br><span class="line">        <span class="keyword">return</span> len1 - len2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>hashCode()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash;</span><br><span class="line">        <span class="comment">//hash是否计算过</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> val[] = value;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">                h = <span class="number">31</span> * h + val[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//给hash赋值</span></span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>concat(String s)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ublic String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">       <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> len = value.length;</span><br><span class="line">       <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">       str.getChars(buf, len);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>trim():去掉字符串首尾的空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line">        <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            st++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>intern方法是Native调用，它的作用是在方法区中的常量池里通过equals方法寻找等值的对象，如果没有找到则在常量池中开辟一片空间存放字符串并返回该对应String的引用，否则直接返回常量池中已存在String对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解-Annotation</title>
    <url>/2017/02/06/Java%E6%B3%A8%E8%A7%A3-Annotation/</url>
    <content><![CDATA[<hr>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GET(&quot;api/getuser/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(<span class="meta">@Path(&quot;username&quot;)</span> String username)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BindView(R.id.btn_getuser)</span></span><br><span class="line">Button getUser;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h2 id="概念以及作用"><a href="#概念以及作用" class="headerlink" title="概念以及作用"></a>概念以及作用</h2><ol>
<li>概念:能够添加到Java源代码的语法元数据。类，方法，变量，参数，包都可以被注解，可以用来将信息元数据与程序元素进行关联。</li>
<li>作用:</li>
</ol>
<ul>
<li>标记，告诉编译器一些信息。</li>
<li>编译时动态处理，如动态生成代码</li>
<li>运行时动态处理，如得到注解信息<a id="more"></a>

</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Annotation其实是一种接口。通过Java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类即使用注解的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。</p>
<p>Annoation和程序代码的隔离性：Annotation是不会影响程序代码的执行，无论Annotation怎么变化，代码都始终如一地执行。</p>
<p>忽略性：Java语言解释器在工作时会忽略这些annotation，因此在JVM 中这些Annotation是“不起作用”的，只能通过配套的工具才能对这些Annontaion类型的信息进行访问和处理。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1.标准Annotation:Java自带的几个Annotation</p>
<ul>
<li>Override 重写方法</li>
<li>Deprecated 不鼓励使用（有更好方式，存在风险，不再维护）</li>
<li>SuppressWarnings 忽略某项Warning</li>
</ul>
<p>2.元Annotation:元注解的作用就是负责注解其他注解</p>
<ul>
<li>@Rerention 保留时间(即:被描述的注解在什么范围内有效)，可选SOURCE(源码时) CLASS(编译时) RUNTIME(运行时）默认CLASS，SOURCE 大都为Mark Annotation（下面会说）这类Annotation大都用来校验，比如Override</li>
<li>@Target 用于描述注解的使用范围(即：被描述的注解可以用在什么地方)。取值(ElementType)有：<br>　　　　1.CONSTRUCTOR:用于描述构造器<br>　　　　2.FIELD:用于描述域即类成员变量<br>　　　　3.LOCAL_VARIABLE:用于描述局部变量<br>　　　　4.METHOD:用于描述方法<br>　　　　5.PACKAGE:用于描述包<br>　　　　6.PARAMETER:用于描述参数<br>　　　　7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
<li>@Inherited 是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</li>
<li>@Documented 也是一个标记注解,代表是否会保存到JavaDoc中</li>
</ul>
<p>3.自定义Annotation:自己根据需要定义的Annotation,定义时需要用上面的元Annotation</p>
<h2 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h2><p>1.定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Ducumented</span></span><br><span class="line"><span class="meta">@Retention</span>（RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span>  <span class="meta">@Interface</span> MethodInfo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">title</span><span class="params">()</span> <span class="keyword">default</span> &quot;tl&quot;</span>;</span><br><span class="line">    <span class="function">String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">content</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过@interface定义</li>
<li>所有方法没有方法体 没有参数和修饰符 默认public</li>
<li>方法返回值只有基本类型，String，Class，annotation，enumeration或者它们的一维数组</li>
<li>一个属性都没有表示该 Annotation 为 Mark Annotation</li>
<li>可以用default表示默认值</li>
<li>只有一个属性时，最好定义为value，因为使用时可以省略”value=”</li>
</ul>
<p>2.使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="meta">@MethodInfo(title = &quot;123&quot;,</span></span><br><span class="line"><span class="meta">               date = &quot;20160912&quot;,</span></span><br><span class="line"><span class="meta">               content = &quot;456745645625&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Notice <span class="title">getNotice</span><span class="params">(）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">         return new Notice()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Annotation解析"><a href="#Annotation解析" class="headerlink" title="Annotation解析"></a>Annotation解析</h2><p>1.运行时Annotation解析（@Retention为RUNTIME)<br>可以用以下方法：</p>
<ul>
<li>method/field/class.getAnnotations(); 得到该Target某个Annotation的信息</li>
<li>method/field/class.getAnnotation(AnnotationName.class); 表示得到该Target所有Annotation</li>
<li>method/field/class.isAnnotationPresent(AnnotationName.class); 表示该Target是否被某个Annotation修饰</li>
</ul>
<p>实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            Class cls=Class.forName(<span class="string">&quot;com.tl.aidl.Test&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(Method method:cls.getMethods())&#123;</span><br><span class="line">                MethodInfo methodInfo=method.getAnnotation(MethodInfo.class);</span><br><span class="line">                <span class="keyword">if</span>(methodInfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    Log.i(TAG,method.getName());</span><br><span class="line">                    Log.i(TAG,methodInfo.title());</span><br><span class="line">                    Log.i(TAG,methodInfo.date());</span><br><span class="line">                    Log.i(TAG,methodInfo.content());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.编译时Annotation解析（@Retention为CLASS）<br>这部分编译器会自动解析，不过我们需要定义一个类继承自AbstractProcessor并重写process方法。编译器就会在编译时自动查找所有继承自AbstractProcessor的类，然后调用它们的process方法处理。</p>
<p>实例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示要处理的Annotation名称</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes(&#123; &quot;com.tl.java.MethodInfo&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInfoProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">   <span class="comment">// annotations-待处理的Annotations</span></span><br><span class="line">   <span class="comment">// env-运行环境</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TypeElement te : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(te)) &#123;</span><br><span class="line">                MethodInfo methodInfo = element.getAnnotation(MethodInfo.class);</span><br><span class="line">                map.put(element.getEnclosingElement().toString(), methodInfo.author());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//表示这组annotation是否被这个Processor接受，如果接受后续的processor不会再对这个Annotations进行处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码浅析(JDK1.8)</title>
    <url>/2018/04/05/HashMap%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<hr>
<h3 id="一-HashMap的定义"><a href="#一-HashMap的定义" class="headerlink" title="一. HashMap的定义"></a>一. HashMap的定义</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>HashMap基于HashTable的Map接口实现（实现了Map接口，继承AbstractMap），此实现提供所有可选的映射操作，并且允许NULL值和NULL键（HashMap类大致相当于HashTable类，但它是非同步的，而且允许空值。）此类不保证映射顺序。由于HashMap不是线程安全的，如果想要线程安全，可以使用ConcurrentHashMap代替。</p>
<p>一个HashMap的实例有两个影响其性能的参数：初始容量（capacity默认是16）和加载因子（load factor默认是0.75），通常缺省的加载因子较好地实现了时间和空间的均衡，增大加载因子虽然说可以节省空间但相对地会增加对应的查找成本，这样会影响HashMap的get和put操作。加载因子表示Hash表中的元素的填满程度，填充得越多对应的查找的时候发生冲突的机率就越大，查找的成本就越高。</p>
<a id="more"></a>
<h4 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储数据的Node数组</span></span><br><span class="line">        <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">        <span class="comment">//返回Map中所包含的Map.Entry&lt;K,V&gt;的Set视图。</span></span><br><span class="line">        <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">        <span class="comment">//当前存储元素的总个数</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="comment">//HashMap内部结构发生变化的次数，主要用于迭代的快速失败（下面代码有分析此变量的作用）</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">        <span class="comment">//下次扩容的临界值，size&gt;=threshold就会扩容，threshold等于capacity*load factor</span></span><br><span class="line">        <span class="keyword">int</span> threshold;</span><br><span class="line">        <span class="comment">//装载因子</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认装载因子</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">        <span class="comment">//由链表转换成红黑树的阈值TREEIFY_THRESHOLD</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">//由红黑树的阈值转换链表成UNTREEIFY_THRESHOLD</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">//默认容量（16）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">         <span class="comment">//数组的最大容量 （1073741824）</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="comment">//当桶中的bin(链表中的元素)被树化时最小的hash表容量。（如果没有达到这个阈值，即hash表容量小于MIN_TREEIFY_CAPACITY，当桶中bin的数量太多时会执行resize扩容操作）这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">        略...</span><br></pre></td></tr></table></figure>
<h4 id="存储查找原理"><a href="#存储查找原理" class="headerlink" title="存储查找原理"></a>存储查找原理</h4><p>存储：首先获取key的hashcode，然后取模数组的长度，这样可以快速定位到要存储到数组中的坐标，然后判断数组中是否存储元素，如果没有存储则，新构建Node节点，把Node节点存储到数组中，如果有元素，则迭代链表(红黑二叉树)，如果存在此key,默认更新value,不存在则把新构建的Node存储到链表的尾部。</p>
<p>查找：同上，获取key的hashcode，通过hashcode取模数组的长度，获取要定位元素的坐标，然后迭代链表，进行每一个元素的key的equals对比，如果相同则返回该元素。</p>
<h3 id="二-HashMap的数据结构"><a href="#二-HashMap的数据结构" class="headerlink" title="二. HashMap的数据结构"></a>二. HashMap的数据结构</h3><p>JDK1.6实现hashmap的方式是采用位桶（数组）+链表的方式，即散列链表方式。JDK1.8则是采用位桶+链表/红黑树的方式，即当某个位桶的链表长度达到某个阈值（8）的时候，这个链表就转化成红黑树，这样大大减少了查找时间。<br><img src="http://autism-tl.cn/picture/HashMap.png" alt="hashmap"><br>下面是HashMap的几个构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据初始化容量和加载因子构建一个空的HashMap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用初始化容量和默认加载因子(0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用默认初始化大小(16)和默认加载因子(0.75).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用已有的Map构造一个新的HashMap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="链表的结构"><a href="#链表的结构" class="headerlink" title="链表的结构"></a>链表的结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next; <span class="comment">// 指向下一个节点</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="红黑二叉树的结构"><a href="#红黑二叉树的结构" class="headerlink" title="红黑二叉树的结构"></a>红黑二叉树的结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       TreeNode&lt;K,V&gt; left;</span><br><span class="line">       TreeNode&lt;K,V&gt; right;</span><br><span class="line">       TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">       <span class="keyword">boolean</span> red;</span><br><span class="line">       TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三-HashMap的数据存取"><a href="#三-HashMap的数据存取" class="headerlink" title="三. HashMap的数据存取"></a>三. HashMap的数据存取</h3><h4 id="HashMap-put（key-value）"><a href="#HashMap-put（key-value）" class="headerlink" title="HashMap.put（key, value）"></a>HashMap.put（key, value）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//p：链表节点  n:数组长度   i：链表所在数组中的索引坐标</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//判断tab[]数组是否为空或长度等于0，进行初始化扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//判断tab指定索引位置是否有元素，没有则直接newNode赋值给tab[i]</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//如果该数组位置存在Node</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//首先先去查找与待插入键值对key相同的Node，存储在e中，k是那个节点的key</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             <span class="comment">// 如果hash、key都相等，直接覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//如果Node是红黑二叉树，则执行树的插入操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//否则执行链表的插入操作（说明Hash值碰撞了，把Node加入到链表中）</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//如果该节点是尾节点，则进行添加操作</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//判断链表长度，如果链表长度大于8则调用treeifyBin方法，判断是扩容还是把链表转换成红黑二叉树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// hash、key都相等，此时即要更新节点并退出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//把p执行p的子节点，开始下一次循环（p = e = p.next）</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断e是否为null，如果为null则表示加了一个新节点，不是null则表示找到了hash、key都一致的Node。</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">//判断是否更新value值。（map提供putIfAbsent方法，如果key存在，不更新value，但是如果value==null任何情况下都更改此值）</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                <span class="comment">//此方法是空方法，什么都没实现，用户可以根据需要进行覆盖</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;链表中原本存在相同的key，则返回oldValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有插入了新节点才进行++modCount；</span></span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//如果size&gt;threshold则开始扩容（每次扩容原来的1倍）</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//此方法是空方法，什么都没实现，用户可以根据需要进行覆盖</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 原HashMap中不存在相同的key，插入键值对后返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ol>
<li>判断键值对数组tab[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3；</li>
<li>判断链表（或二叉树）的首个元素是否和key一样，不一样转向4，相同则覆盖后转向6；</li>
<li>判断链表（或二叉树）的首节点 是否为treeNode，即是否是红黑树，如果是红黑树，则直接在树中插入键值对，不是则执行5；</li>
<li>遍历链表，判断链表长度是否大于8，大于8的话把链表转换为红黑树（还判断数组长度是否小于64，如果小于只是扩容，不进行转换二叉树），在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；如果调用putIfAbsent方法插入，则不更新值（只更新值为null的元素）。</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先判断数组的长度是否小于64，如果小于64则进行扩容，否则把链表结构转换成红黑二叉树结构。</p>
<p>modCount 变量的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> mc = modCount;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从forEach循环中可以发现 modCount 参数的作用。就是在迭代器迭代输出Map中的元素时，不能编辑（增加，删除，修改）Map中的元素。如果在迭代时修改，则抛出ConcurrentModificationException异常。</p>
<h4 id="HashMap-get（key）"><a href="#HashMap-get（key）" class="headerlink" title="HashMap.get（key）"></a>HashMap.get（key）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 红黑树</span></span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="comment">// 链表</span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历红黑树搜索节点</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Calls find for root node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> r;</span><br><span class="line">           r = p;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Finds the node starting at root p with the given hash and key.</span></span><br><span class="line"><span class="comment">    * The kc argument caches comparableClassFor(key) upon first use</span></span><br><span class="line"><span class="comment">    * comparing keys.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">           TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">           <span class="keyword">if</span> ((ph = p.hash) &gt; h) <span class="comment">// 当前节点hash大</span></span><br><span class="line">               p = pl; <span class="comment">// 查左子树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) <span class="comment">// 当前节点hash小</span></span><br><span class="line">               p = pr; <span class="comment">// 查右子树</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">               <span class="keyword">return</span> p; <span class="comment">// hash、key都相等，即找到，返回当前节点</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>) <span class="comment">// hash相等，key不等，左子树为null，查右子树</span></span><br><span class="line">               p = pr;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">               p = pl;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                     (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                    (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">               p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">               <span class="keyword">return</span> q;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               p = pl;</span><br><span class="line">       &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="四-细节解析"><a href="#四-细节解析" class="headerlink" title="四.细节解析"></a>四.细节解析</h3><h4 id="hash取余数，为什么不用取模操作呢，而用tab-i-n-1-amp-hash-？"><a href="#hash取余数，为什么不用取模操作呢，而用tab-i-n-1-amp-hash-？" class="headerlink" title="hash取余数，为什么不用取模操作呢，而用tab[i = (n - 1) &amp; hash]？"></a>hash取余数，为什么不用取模操作呢，而用tab[i = (n - 1) &amp; hash]？</h4><p>它通过 (n - 1) &amp; hash来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时， (n - 1) &amp; hash运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。<br>用位来保存对象的位置同时也省去了重新计算hash值的时间。</p>
<h4 id="hashmap查询的时间复杂度？"><a href="#hashmap查询的时间复杂度？" class="headerlink" title="hashmap查询的时间复杂度？"></a>hashmap查询的时间复杂度？</h4><p>最好O（1），最差O（n）， 如果是红黑O（logn）</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android消息机制</title>
    <url>/2017/01/07/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<hr>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>Android的消息机制由Handler，MessageQueue与Looper支撑，Handler是消息机制的上层接口，在开发过程中主要与Handler打交道。<br>MessageQueue为消息队列，它在内部存储了一组消息，以队列的形式对外提供插入与删除的工作（内部存储采用单链表的数据结构）。<br>Looper的中文翻译为循环，它以无限循环的方式去查找MessageQueue中是否有消息，如果有就处理消息，否则一直等待。<br>Handler在创建的时候会采用当前线程的Looper构建消息循环系统，而Looper使用ThreadLocal（一个线程内部的数据存储类，可以在不同线程中互不干扰地存储并提供数据）使得每个线程都有一个Looper。<br>不过线程默认没有Looper（ui线程除外），如果需要使用Handler就必须为线程创建Looper。UI线程就是ActivityThread，它会在创建的时候初始化Looper。</p>
<a id="more"></a> 
<h2 id="UI不能在子线程中访问的原因"><a href="#UI不能在子线程中访问的原因" class="headerlink" title="UI不能在子线程中访问的原因"></a>UI不能在子线程中访问的原因</h2><p>Handler并不是专门用于更新UI的，但很多时候它都被开发者用来更新UI，那为什么必须在主线程中才能操作UI呢？主要是因为Android的UI控件不是线程安全的，如果在多线程并发访问会导致UI控件出现不可预料到结果。那为什么不能加锁呢？首先是加锁会让UI访问得逻辑变得复杂，然后也会降低UI访问的效率，因为锁机制会阻塞一些线程的执行。所以最简单高效的方法就是采用单线程模型来处理UI操作。</p>
<h1 id="Message与MessageQueue工作原理"><a href="#Message与MessageQueue工作原理" class="headerlink" title="Message与MessageQueue工作原理"></a>Message与MessageQueue工作原理</h1><p>对于Android消息机制我们从最熟悉的Message开始，Message用于存储传递的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* arg1 and arg2 are lower-cost alternatives to using﻿</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if *you only need to store a﻿ few integer *values.﻿</span></span><br><span class="line"><span class="comment">*arg1和arg2是低成本数据的选择方案</span></span><br><span class="line"><span class="comment">*如果只要存储一些integer只用选择它*们，不必使用setData();</span></span><br><span class="line"><span class="comment">    */</span>﻿</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> arg1;﻿﻿</span><br><span class="line">   <span class="comment">/**﻿</span></span><br><span class="line"><span class="comment">    * arg1 and arg2 are lower-cost alternatives to using﻿</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a﻿</span></span><br><span class="line"><span class="comment">    * few integer values.﻿</span></span><br><span class="line"><span class="comment">    */</span>﻿</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   User-defined message code so that the recipient can identify what this message is about. Each Handler has its own name-space for message codes, so you do not need to worry about yours conflicting with other handlers.</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">用户自定义的消息代码，这样接受者可以确定这个消息的信息。每个handler各自包含自己的消息代码，所以不用担心自定义的消息跟其他handlers有冲突。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> what</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="keyword">public</span> Object obj</span><br></pre></td></tr></table></figure>
<p>创建Message不必使用它的构造方法，使用obtain();可以从Message池中取出一个Message,避免多次创建新的Message对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* Return a <span class="keyword">new</span> Message instance from the global pool. Allows us to﻿</span><br><span class="line">    * avoid allocating <span class="keyword">new</span> objects in many cases.﻿</span><br><span class="line">    */﻿</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;﻿</span><br><span class="line">       <span class="keyword">synchronized</span> (sPoolSync) &#123;﻿</span><br><span class="line">           <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">               Message m = sPool;﻿</span><br><span class="line">               sPool = m.next;﻿</span><br><span class="line">               m.next = <span class="keyword">null</span>;﻿</span><br><span class="line">               m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag﻿</span></span><br><span class="line">               sPoolSize--;﻿</span><br><span class="line">               <span class="keyword">return</span> m;﻿</span><br><span class="line">           &#125;﻿</span><br><span class="line">       &#125;﻿</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Message();﻿</span><br><span class="line">   &#125;﻿﻿</span><br><span class="line">   <span class="comment">/**﻿</span></span><br><span class="line"><span class="comment">    * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but copies the values of an existing﻿</span></span><br><span class="line"><span class="comment">    * message (including its target) into the new one.﻿</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> orig Original message to copy.﻿</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> A Message object from the global pool.﻿</span></span><br><span class="line"><span class="comment">    */</span>﻿</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span> </span>&#123;﻿</span><br><span class="line">       Message m = obtain();﻿</span><br><span class="line">       m.what = orig.what;﻿</span><br><span class="line">       m.arg1 = orig.arg1;﻿</span><br><span class="line">       m.arg2 = orig.arg2;﻿</span><br><span class="line">       m.obj = orig.obj;﻿</span><br><span class="line">       m.replyTo = orig.replyTo;﻿</span><br><span class="line">       m.sendingUid = orig.sendingUid;﻿</span><br><span class="line">       <span class="keyword">if</span> (orig.data != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">           m.data = <span class="keyword">new</span> Bundle(orig.data);﻿</span><br><span class="line">       &#125;﻿</span><br><span class="line">       m.target = orig.target;﻿</span><br><span class="line">       m.callback = orig.callback;﻿﻿</span><br><span class="line">       <span class="keyword">return</span> m;﻿</span><br><span class="line">   &#125;﻿﻿</span><br><span class="line">   <span class="comment">/**﻿</span></span><br><span class="line"><span class="comment">    * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the value for the target member on the Message returned.﻿</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> h  Handler to assign to the returned Message object&#x27;s target member.﻿</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> A Message object from the global pool.﻿</span></span><br><span class="line"><span class="comment">    */</span>﻿</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;﻿</span><br><span class="line">       Message m = obtain();﻿</span><br><span class="line">       m.target = h;﻿﻿</span><br><span class="line">       <span class="keyword">return</span> m;﻿</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看下常用的sendMessage()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span>﻿</span>&#123;﻿</span><br><span class="line"><span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);﻿</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;﻿</span><br><span class="line">       Message msg = Message.obtain();﻿</span><br><span class="line">       msg.what = what;﻿</span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);﻿</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>都调用到sendMessageDelayed</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span>﻿</span></span><br><span class="line"><span class="function">  </span>&#123;﻿</span><br><span class="line">      <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;﻿</span><br><span class="line">          delayMillis = <span class="number">0</span>;﻿</span><br><span class="line">      &#125;﻿</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);﻿</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;﻿</span><br><span class="line">       MessageQueue queue = mQueue;﻿</span><br><span class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(﻿</span><br><span class="line">                   <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);﻿</span><br><span class="line">           Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);﻿</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;﻿</span><br><span class="line">       &#125;﻿</span><br><span class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);﻿&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;﻿</span><br><span class="line">       msg.target = <span class="keyword">this</span>;﻿</span><br><span class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;﻿</span><br><span class="line">           msg.setAsynchronous(<span class="keyword">true</span>);﻿</span><br><span class="line">       &#125;﻿</span><br><span class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);﻿</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里就给target赋值为this,就是上面说的target就是Handler了，所以最终会调用queue的enqueueMessage的方法，这就是MessageQueue的插入了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                msg.recycle();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.markInUse();</span><br><span class="line">            msg.when = when;</span><br><span class="line">            Message p = mMessages;</span><br><span class="line">            <span class="keyword">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">                <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">                <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">                needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">                Message prev;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    prev = p;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                        needWake = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">                prev.next = msg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>enqueueMessage的实现中可以看出，它的主要操作就是单链表的插入操作。</p>
<p>在MessageQueue中还有一个重要方法：读取 next方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">        <span class="comment">// which is not supported.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">                Binder.flushPendingCommands();</span><br><span class="line">            &#125;</span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">                Message msg = mMessages;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        prevMsg = msg;</span><br><span class="line">                        msg = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Got a message.</span></span><br><span class="line">                        mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            prevMsg.next = msg.next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            mMessages = msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// No more messages.</span></span><br><span class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                    dispose();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">                <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">                <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Run the idle handlers.</span></span><br><span class="line">            <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">                mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line">                <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    keep = idler.queueIdle();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        mIdleHandlers.remove(idler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出next方法就是一个无限循环的方法，消息队列没有消息，next方法就一直阻塞在那里，当有消息的时候，next方法就会返回这条消息并将其从单链表中移除。</p>
<h1 id="Looper工作原理"><a href="#Looper工作原理" class="headerlink" title="Looper工作原理"></a>Looper工作原理</h1><p>Looper在Android消息机制中扮演着消息循环的角色，具体来说就是以无限循环的方式去查找MessageQueue中是否有消息，如果有就处理消息，否则一直阻塞在那里。<br>我们知道，Handler工作需要Looper，没有Looper就会报错，那么，怎么创建Looper呢？其实就是通过Looper.prepare()就可以为当前线程创建一个Looper，接着通过Looper.loop()就可以开启消息循环了。<br>首先我们看一下它的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span></span>&#123;</span><br><span class="line">   mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">   mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中它会创建一个MessageQueue即消息队列，然后将当前线程的对象保存起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.﻿</span></span><br><span class="line"><span class="comment">   * This gives you a chance to create handlers that then reference﻿</span></span><br><span class="line"><span class="comment">   * this looper, before actually starting the loop. Be sure to call﻿</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling﻿</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> #quit()&#125;.﻿</span></span><br><span class="line"><span class="comment">   */</span>﻿</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;﻿</span><br><span class="line">     prepare(<span class="keyword">true</span>);﻿</span><br><span class="line"> &#125;﻿﻿</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;﻿</span><br><span class="line">     <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);﻿</span><br><span class="line">     &#125;﻿</span><br><span class="line">     sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));﻿</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>hreadLocal是一个ThreadLocal对象，可以在一个线程中存储变量。可以看到，将一个Looper的实例放入了ThreadLocal，并且11行判断了sThreadLocal是否为null，否则抛出异常。这也就说明了Looper.prepare()方法不能被调用两次，同时也保证了一个线程中只有一个Looper实例,接下来是loop()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**﻿</span></span><br><span class="line"><span class="comment">  * Run the message queue in this thread. Be sure to call﻿</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.﻿</span></span><br><span class="line"><span class="comment">  */</span>﻿</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;﻿</span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();﻿</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);﻿</span><br><span class="line">     &#125;﻿</span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;﻿﻿</span><br><span class="line">     <span class="comment">// Make sure the identity of this thread is that of the local process,﻿</span></span><br><span class="line">     <span class="comment">// and keep track of what that identity token actually is.﻿</span></span><br><span class="line">     Binder.clearCallingIdentity();﻿</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();﻿﻿</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;﻿</span><br><span class="line">         Message msg = queue.next(); <span class="comment">// might block﻿</span></span><br><span class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">             <span class="comment">// No message indicates that the message queue is quitting.﻿</span></span><br><span class="line">             <span class="keyword">return</span>;﻿</span><br><span class="line">         &#125;﻿﻿</span><br><span class="line">         <span class="comment">// This must be in a local variable, in case a UI event sets the logger﻿</span></span><br><span class="line">         Printer logging = me.mLogging;﻿</span><br><span class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">             logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +﻿</span><br><span class="line">                     msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);﻿</span><br><span class="line">         &#125;﻿﻿</span><br><span class="line">         msg.target.dispatchMessage(msg);﻿﻿</span><br><span class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">             logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);﻿</span><br><span class="line">         &#125;﻿﻿</span><br><span class="line">         <span class="comment">// Make sure that during the course of dispatching the﻿</span></span><br><span class="line">         <span class="comment">// identity of the thread wasn&#x27;t corrupted.﻿</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();﻿</span><br><span class="line">         <span class="keyword">if</span> (ident != newIdent) &#123;﻿</span><br><span class="line">             Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span>﻿</span><br><span class="line">                     + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span>﻿</span><br><span class="line">                     + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span>﻿</span><br><span class="line">                     + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span>﻿</span><br><span class="line">                     + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);﻿</span><br><span class="line">         &#125;﻿﻿</span><br><span class="line">         msg.recycleUnchecked();﻿</span><br><span class="line">     &#125;﻿</span><br><span class="line"> &#125;﻿﻿</span><br><span class="line"> <span class="comment">/**﻿</span></span><br><span class="line"><span class="comment">  * Return the Looper object associated with the current thread.  Returns﻿</span></span><br><span class="line"><span class="comment">  * null if the calling thread is not associated with a Looper.﻿</span></span><br><span class="line"><span class="comment">  */</span>﻿</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;﻿</span><br><span class="line">     <span class="keyword">return</span> sThreadLocal.get();﻿</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>方法中直接获取了sThreadLocal存储的Looper实例，如果me为null则抛出异常，这就是说looper方法必须在prepare方法之后才运行。﻿然后拿到该looper实例中的mQueue，就进入了无限循环。﻿然后一直取出一条消息，直到没有消息则阻塞。子线程Looper用完建议终止（调用quit方法），否则loop方法会无限循环下去，子线程会一直处于等待的状态。</p>
<p>获取消息后使用msg.target.dispatchMessage(msg);把消息交给msg的target的dispatchMessage方法去处理。Msg的target是什么呢？其实就是handler对象。但是这里不同的是，Handle的dispatchMessage方法是在创建Handle时所使用的Looper中执行的，这样就成功的完成了线程切换。</p>
<h1 id="Handler原理"><a href="#Handler原理" class="headerlink" title="Handler原理"></a>Handler原理</h1><p>Handler的工作主要包括消息的发送和接受过程。消息发送可以通过post或者send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。处理消息最终会调用Handler的dispatchMessage方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**﻿</span></span><br><span class="line"><span class="comment"> * Handle system messages here.﻿</span></span><br><span class="line"><span class="comment"> */</span>﻿</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;﻿</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">        handleCallback(msg);﻿</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;﻿</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;﻿</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;﻿</span><br><span class="line">                <span class="keyword">return</span>;﻿</span><br><span class="line">            &#125;﻿</span><br><span class="line">        &#125;﻿</span><br><span class="line">        handleMessage(msg);﻿</span><br><span class="line">    &#125;﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**﻿</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.﻿</span></span><br><span class="line"><span class="comment"> */</span>﻿</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;﻿</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是个空方法，所以需要我们对它进行复写。于是乎，处理Message就交到我们手中了。</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Unicode编码</title>
    <url>/2019/08/21/Unicode%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<hr>
<h2 id="Unicode的前因后果"><a href="#Unicode的前因后果" class="headerlink" title="Unicode的前因后果"></a>Unicode的前因后果</h2><p>计算机没法直接处理文本，它只和0 1数字打交道。为了在计算机里用数字表示文本，我们指定了一个从字符到数字的映射。这个映射就叫做编码（encoding）。</p>
<p><strong>1967年</strong>，字符编码<strong>ASCII</strong>正式发布。ASCII 码是 7 位的，它将英文字母，数字 0-9 以及一些标点符号和控制字符映射为 0-127 这些整型。 英语用 128 个字符来编码完全是足够的，但是用来表示其他语言，128 个字符是远远不够的。亚洲语言有更多的字符需要被存储，一个字节已经不够用了。于是，人们开始使用两个字节来存储字符。</p>
<p>各种各样不统一的编码方式成了系统开发者的噩梦，他们提出了一个<strong>“内码表”</strong>的概念，可以切换到相应语言的一个内码表，这样才能显示相应语言的字母。如果你在一台机器上写了一段文字，然后在另一台使用了不同的内码表的机器上打开就会显示出错误。在这种情况下，如果使用多语种，那么就需要频繁的在内码表内进行切换。</p>
<p><strong>1987年</strong>，来自几个大的科技公司（其中包括苹果和 NeXT）的工程师们开始合作致力于开发一种能在全世界所有书写系统中通用的字符编码系统，于 1991 年 10 月发布的 1.0.0 版本的 Unicode 标准就是这一努力的成果。</p>
<p><strong>Unicode</strong> 是一本很厚的字典，为世界上几乎所有的书写系统里所使用的每一个字符或符号定义了一个唯一的数字。这个数字叫做<strong>码点（code points）</strong>。最初，Unicode 编码是被设计为 16 位的，提供了 65,536 个字符的空间。后来考虑到要编码历史上的文字以及一些很少使用的日本汉字和<strong>中国汉字</strong>，Unicode 编码扩展到了 21 位（从 U+0000 到 U+<strong>10FFFF</strong>），这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，还有很大的扩充空间。</p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_1.png" alt="image-20210403204705833"></p>
<p>Unicode编码空间被分成 17(1+2^4)个<strong>平面</strong>，每个平面有 65,536 (2^16)个字符。0 号平面叫做<strong>「基本多文种平面」</strong>，涵盖了几乎所有你能遇到的字符，<strong>除了 emoji</strong>。其它平面叫做辅助平面，大多是空的。</p>
<h2 id="Unicode编码解码"><a href="#Unicode编码解码" class="headerlink" title="Unicode编码解码"></a>Unicode编码解码</h2><p>Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，实现了对 ASCII 码的向后兼容。它的最大特点就是可变长，它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下：</p>
<p>1、对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。意味着 ASCII 码用 UTF-8 编码兼容完全没有问题。</p>
<p>2、对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。</p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_2.png" alt="image-20210403204705833"></p>
<p>“汉”的 Unicode 码点是 0x6c49（110 1100 0100 1001），0x6c49 需要15位二进制位数，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“汉”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100110 10110001 10001001，转换成十六进制就是 0xE6 0xB1 0x89。  </p>
<p>解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。编码规则：<strong>基本平面的字符占用 2 个字节（U+0000 到 U+FFFF），辅助平面的字符占用 4 个字节（U+010000 到 U+10FFFF）</strong>。</p>
<p>当我们遇到两个字节时，到底是把这两个字节当作一个字符还是与后面的两个字节一起当作一个字符呢？</p>
<p>辅助平面的字符位共有 2^20 (2^4个平面，每个里面 2^16)个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L），剩下的6位当做标志来区分基本平面和辅助 平面。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。</p>
<p>为了配合UTF-16，Unicode中也将这两个区间屏蔽掉，不允许分配任何字符</p>
<p>1101 10xx xxxx xxxx，区间就是D800~DBFF</p>
<p>1101 11xx xxxx xxxx，区间就是DC00~DFFF</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>UTF-32每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。</p>
<h2 id="Unicode中的Emoji"><a href="#Unicode中的Emoji" class="headerlink" title="Unicode中的Emoji"></a>Unicode中的Emoji</h2><blockquote>
<p>1999年前后，日本一个名叫栗田穰崇的年轻人，和许多直男一样， 给女友发的短信经常会被误解。比如，“知道了”被解读成“生气了”、“不耐烦了”，随后引发冷战。 于是少年栗田想：“如果能在文字里插入一些表情符号来表达感情，大家应该会需要吧！”</p>
</blockquote>
<blockquote>
<p>原始的Emoji就这么诞生了。</p>
</blockquote>
<h3 id="Emoji的编码"><a href="#Emoji的编码" class="headerlink" title="Emoji的编码"></a>Emoji的编码</h3><p>在普通的聊天软件中，一些基本表情是采用普通字符的转义表示。比如在字符串中检测到[微笑]，就自动替换为表情图片。</p>
<p>但是Emoji是一种特殊的字符，它是真正被编码入Unicode的字符。大部分Emoji在字符集里处于U+1F300到U+1F9EF中的部分范围（1号平面）。</p>
<h3 id="Unicode组合字符"><a href="#Unicode组合字符" class="headerlink" title="Unicode组合字符"></a>Unicode组合字符</h3><p>Unicode 包含一个系统，可以合并多个编码点，动态组合字符。此系统用各种方式增加灵活性，而不引起编码点的巨大组合膨胀。</p>
<p>用户认为的一个“字符” 事实上底下可能由多个编码点组成。Unicode 使用「字位簇」的概念来表示这种情况。一个由一个或多个编码点组成的字符串构成一个 “用户感知的字符”。</p>
<p>字位簇主要被用在文本编辑：它们对光标和文本选择来说是最明显的单元。使用字位簇，确保在复制和粘贴文本时不会突然丢掉一些符号，同时左右方向键也总是以一个可见字符的距离移动，等等。</p>
<p><a href="https://juejin.im/post/5c00b31a5188251d9e0c4a59">更多Emoji组合字符信息</a></p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val smile  &#x3D;  &quot;😀&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;smile emoji length &#x3D; $&#123;smile.length&#125;&quot;)</span><br><span class="line"></span><br><span class="line">val flag &#x3D; &quot;🇨🇳&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;flag emoji length &#x3D; $&#123;flag.length&#125;&quot;)</span><br><span class="line"></span><br><span class="line">val portrait &#x3D; &quot;👩🏽‍🦳&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;portrait emoji length &#x3D; $&#123;portrait.length&#125;&quot;)</span><br><span class="line"></span><br><span class="line">val family &#x3D; &quot;👨‍👩‍👧‍👧&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;family emoji length &#x3D; $&#123;family.length&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">smile emoji length &#x3D; 2 </span><br><span class="line"></span><br><span class="line">flag emoji length &#x3D; 4 </span><br><span class="line"></span><br><span class="line">portrait emoji length &#x3D; 7 </span><br><span class="line"></span><br><span class="line">family emoji length &#x3D; 11</span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Java-Android与Unicode"><a href="#Java-Android与Unicode" class="headerlink" title="Java/Android与Unicode"></a>Java/Android与Unicode</h2><p>Java最初设计的Charactor用两个字节来表示unicode字符，这没有问题， 因为最初unicode只有16位并且字符还比较少，但是Unicode 4.0(事实上自Unicode 3.1), 字符集进行很大的扩充，已经达到了96,447个字符，Unicode 11.0已经包含137,374个字符，2^16已经远远不够存储了。</p>
<h3 id="Java编码方式：JVM之外和JVM之内"><a href="#Java编码方式：JVM之外和JVM之内" class="headerlink" title="Java编码方式：JVM之外和JVM之内"></a>Java编码方式：JVM之外和JVM之内</h3><p>JVM之外：Java源文件(.java)和编译后的.class文件，源文件可以采用多种编码格式如utf-8(unix linux平台默认) 或者gbk(windows平台默认)，当将源码用javac编译的时候，<strong>默认是javac按照系统默认的编码格式读取java源文件</strong>， 然后以utf-8的格式输出到.class文件中，换句话说，在默认情况下unix平台，javac用utf-8格式读取java源文件 然后以utf-8格式写.class；在默认情况下windows平台，javac用gbk格式读取java源文件然后以utf-8格式写.class</p>
<p>如果源文件的编码格式不采用操作系统默认格式可能会导致错误表现，在windows平台下用utf-8格式保存java源文件，如果不采用Ide(Ide会智能根据文件编码格式告诉javac用正确的方式)，直接用javac编译该源文件，则会造成乱码（文件保存编码格式和读取编码格式的不匹配）</p>
<p>JVM之内：当运行java字节码时，读入到内存里的字符或者字符串全部都用char或char[]表示，而char是采用UTF-16的 </p>
<h3 id="Android编码方式"><a href="#Android编码方式" class="headerlink" title="Android编码方式"></a>Android编码方式</h3><p>Android系统是基于linux内核的，所以默认的Unicode编码方式为UTF-8</p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_3.png" alt="img"></p>
<h3 id="开发中处理Unicode"><a href="#开发中处理Unicode" class="headerlink" title="开发中处理Unicode"></a>开发中处理Unicode</h3><ul>
<li><blockquote>
<p><strong>Code Point</strong>: 代码点，一个字符的数字表示。一个字符集一般可以用一张或多张由多个行和多个列所构成的二维表来表示。二维表中行与列交叉的点称之为代码点，每个码点分配一个唯一的编号数字，称之为码点值或码点编号，除开某些特殊区域(比如代理区、专用区)的非字符代码点和保留代码点，每个代码点唯一对应于一个字符。 从U+0000 到 U+10FFFF。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Code Unit</strong>：代码单元，是指一个已编码的文本中具有最短的比特组合的单元。对于 UTF-8 来说，代码单元是 8 比特长；对于 UTF-16 来说，代码单元是 16 比特长。换一种说法就是 UTF-8 的是以一个字节为最小单位的，UTF-16 是以两个字节为最小单位的。</p>
</blockquote>
</li>
</ul>
<p>Java的字符在内部以UTF-16编码方式来表示，当字符的Code Point在0号平面，一个Code Unit就能标识字符。<strong>日常开发中需要注意的是一些不常用汉字和emoji，他们会占用多个**</strong>Code Unit**<strong>。</strong></p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_4.png" alt="img"></p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_5.png" alt="img"></p>
<p>String.length返回的是Code Unit的长度，而不是Unicode中字符的长度。对于0号平面的代码点，String.length和我们传统理解的字符的数量是一致的，对于扩展的字符，String.length可能是我们理解的字符长度的两倍，组合字符可能会有更多变化。</p>
<p>以汉字”𠮷”为例，汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。</p>
<p>所以我们平时在进行字符串截取的时候，不能太过依赖String.length的结果，尤其是经常使用的emojis字符。</p>
<p>自 Java 1.5 java.lang.String就提供了Code Point相关方法， 用来获取完整的Unicode字符和Unicode字符数量:</p>
<ul>
<li>public int codePointAt(int index)    //获取index代码点的十进制表示</li>
<li>public int codePointBefore(int index)     //获取index-1代码点的十进制表示</li>
<li><strong>public int codePointCount(int beginIndex, int endIndex)</strong>      //获取beginIndex到endIndex之间的<strong>代码点数量</strong></li>
<li><strong>public default IntStream codePoints()</strong>   String.codePoints().toArray()可以得到代码点的十进制数组</li>
</ul>
<p>注意这些方法中的index使用的是code unit值。</p>
<h3 id="编码方式的encode-decode"><a href="#编码方式的encode-decode" class="headerlink" title="编码方式的encode/decode"></a>编码方式的encode/decode</h3><p>利用String.getBytes() 和 new String() 来进行编码转换</p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_6.png" alt="img"></p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_7.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s&#x3D;&quot;你好&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">byte[] bytes&#x3D;s.getBytes();&#x2F;&#x2F;andorid平台默认是utf-8,编码每个字符占3个字节</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(bytes));&#x2F;&#x2F;[-28, -67, -96, -27, -91, -67]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String s1&#x3D;new String(s.getBytes(&quot;utf-8&quot;), &quot;gbk&quot;);&#x2F;&#x2F;浣犲ソ</span><br><span class="line"></span><br><span class="line">String s1&#x3D;new String(s.getBytes(&quot;gbk&quot;), &quot;utf-8&quot;);&#x2F;&#x2F;???</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确转码方式</span><br><span class="line"></span><br><span class="line">return new String( s.getBytes(&quot;utf-8&quot;) , &quot;utf-8&quot;);</span><br></pre></td></tr></table></figure>


<p>URLEncoder.<em>encode</em>(url)/URLDecoder.<em>decode</em>(url) </p>
<p><img src="/2019/08/21/Unicode%E7%BC%96%E7%A0%81/unicode_image_8.png" alt="img"></p>
]]></content>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>插件化-Android资源解析</title>
    <url>/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<hr>
<h2 id="资源编译打包流程："><a href="#资源编译打包流程：" class="headerlink" title="资源编译打包流程："></a>资源编译打包流程：</h2><h3 id="资源文件分类"><a href="#资源文件分类" class="headerlink" title="资源文件分类"></a>资源文件分类</h3><ul>
<li>assets</li>
<li>res：<em>animator、anim、color、drawable、layout、menu、values、xml、raw</em></li>
</ul>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_1.png" alt="image-20210403213115055"></p>
<ul>
<li>res文件夹下除了图片文件和res/raw目录的资源，其他资源均会从文本格式的xml文件编译成二进制格式的xml文件</li>
<li>二进制的xml文件占用空间小，解析速度快。所有的xml标签、属性名称、属性值都会收敛到统一的资源池中，并且会去重。</li>
<li>资源池中会赋予每个非assets资源一个整数ID值，这些ID值以常量/静态变量的形式定义在R.java文件中，并生成resources.arsc文件，用来描述ID值对应资源的配置信息，相当于是一个资源索引表</li>
</ul>
<h3 id="AAPT-Android-Asset-Packaging-Tool-流程："><a href="#AAPT-Android-Asset-Packaging-Tool-流程：" class="headerlink" title="AAPT(Android Asset Packaging Tool)流程："></a>AAPT(Android Asset Packaging Tool)流程：</h3><p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_2.png" alt="image-20210403213223823"></p>
<p><strong>资源表的概念</strong>：aapt在编译应用资源时，会创建一个资源表(使用<strong>ResourceTable</strong>对象来描述)，在应用程序资源编译完成之后，它就会包含所有资源的信息。有这个资源表之后，aapt就可以根据它的内容来生成资源索引表文件resources.arsc了。</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_3.png" alt="img" style="zoom:67%;"><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_4.png" alt="img" style="zoom: 50%;"></p>
<ol>
<li><strong>解析AndroidManifest.xml：</strong>根据package属性值拿到包名并创建一个<strong>ResourceTable</strong>对象</li>
<li><strong>添加被引用的资源包：</strong>除了应用程序的资源包外，我们通常会引用到系统资源包，例如android:layout_height属性的值为“match_parent”，match_parent实际上就是系统资源包里定义的一个值。系统资源包的packageId等于0x01，应用程序资源包的packageId等于0x7f，每一个资源包都用一个Package对象来描述。</li>
<li><strong>收集资源文件添加到资源表：</strong>根据资源的类型(drawable、layout等)创建对应的ResourceTypeSet，把不同type的资源项(用Entry对象描述)添加到对应的ResourceTypeSet中，然后将所有的ResourceTypeSet对象都添加到ResourceTable.Package对象中。至此资源表中资源项的资源ID都可以确定了，由PackageId+TypeId+EntryId(表中的index)决定</li>
<li><strong>编译Xml资源文件：</strong>经历过上述的步骤之后，为编译xml文件做好了所有的准备。</li>
</ol>
<ul>
<li>解析xml：解析xml为内存中的树形结构XMLNode类，每一个XMLNode代表了一个XML元素</li>
<li>赋予属性名称资源ID：给每一个属性名称赋予资源ID。这一步操作会从跟节点开始递归，读取内存中<strong>ResourceTable</strong>对象获取资源ID。系统定义的属性(android:layout_height)赋予0x01XXXXXX，应用程序内定义的属性(<strong>自定义属性</strong>)赋予0x7fXXXXXX</li>
<li>解析属性值：这一步是针对属性名称的值进行解析。对于引用类型的属性值例如@+id/test，如果资源表对应的包中没有test资源，则会增加类型为id的Entry到资源包里</li>
<li>xml文件转换为二进制格式：前面的步骤将所有的资源都解析完毕，接下来将解析过的资源收集起来写入二进制文件</li>
</ul>
<ol>
<li><strong>生成资源索引表resources.arsc：</strong>读取内存中的资源表-收集类型字符串-收集资源项名称字符串-收集资源项值字符串-生成Package数据-依次写入资源索引表</li>
</ol>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_5.png" alt="img"></p>
<ol>
<li><strong>编译AndroidManifest.xml文件：</strong>编译过程与其它的xml资源文件的编译过程一致，之所以要在应用程序的所有资源项都编译完成之后，再编译应用程序的配置文件，是因为后者可能会引用到前者。</li>
<li><strong>生成R.java文件：</strong>在前面的步骤中，已经将所有的资源项及其所对应的资源ID都收集起来了，这里只要直接将它们写入到指定的R.java文件去就可以了。</li>
<li><strong>打包到APK文件：</strong>所有资源都编译完成，可以打包到apk文件中了。</li>
</ol>
<p>包括assets目录、资源项索引文件resources.arsc、res目录(不包含res/value目录，因为该目录下的资源比较简单，直接写到了resources.arsc文件里)。</p>
<p>除了这些资源文件外，应用程序的配置文件AndroidManifest.xml以及应用程序代码文件classes.dex，还有用来描述应用程序的签名信息的文件，也会一并被打包到APK文件中。</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_6.png" alt="img"></p>
<h3 id="AAPT2流程"><a href="#AAPT2流程" class="headerlink" title="AAPT2流程"></a>AAPT2流程</h3><p>从 AGP(Android Gradle Plugin) 3.0.0 开始，AAPT2 默认开启，也可以在配置文件中设置android.enableAapt2=false手动关闭</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_7.png" alt="img"></p>
<p>aapt只有一个编译过程，aapt2将资源编译分为编译-链接2个部分，实现资源文件的增量编译。</p>
<ul>
<li><strong>编译阶段：</strong>解析资源文件并生成扩展名为.flat的中间二进制文件</li>
<li><strong>链接阶段：</strong>将编译阶段生成的所有中间文件(资源表、二进制XML文件和处理过的PNG文件)合并打包到APK文件中，此外在此阶段还可以生成其他辅助文件，如R.java文件和ProGurad规则文件。 </li>
</ul>
<h2 id="资源初始化"><a href="#资源初始化" class="headerlink" title="资源初始化"></a>资源初始化</h2><p>App在启动阶段调用AssetManager.addAssetPath(String path)方法把apk文件目录传递进去，将所有的apk信息保存到ApkAssets数组里</p>
<h2 id="资源查找："><a href="#资源查找：" class="headerlink" title="资源查找："></a>资源查找：</h2><h3 id="调用方式："><a href="#调用方式：" class="headerlink" title="调用方式："></a><strong>调用方式：</strong></h3><ul>
<li>assets：AssetManager.open</li>
<li>res：getString(resId)、getColor(resId)、getDrawable(resId)…</li>
</ul>
<img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_8.png" alt="img" style="zoom:50%;">

<p>内部均是通过AssetManager去搜索apk里面的资源</p>
<h3 id="调用关系图"><a href="#调用关系图" class="headerlink" title="调用关系图"></a>调用关系图</h3><p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_9.png" alt="img"></p>
<p>AssetManager(Java)：</p>
<p>Resources类不管通过什么方式获取资源，最终都是调用AssetManager.getResourceValue方法传入资源ID去查找资源值。getResourceValue再调用底层<em>nativeGetResourceValue方法</em></p>
<p>AssetManager(C++)：</p>
<ol>
<li>AssetManager.getResTable：依次解析应用程序的每一个resources.arcs文件，转换为Asset对象，并将解析完成的Asset对象都添加到ResTable对象中。ResTable对象类似aapt过程中的ResourceTable，里面包含了所有资源信息。</li>
<li>ResTable.getResource(resID…)：通过传入的资源的ID分别获得它的Package ID、Type ID以及Entry ID来查表找到对应的资源Entry</li>
</ol>
<h2 id="资源插件化"><a href="#资源插件化" class="headerlink" title="资源插件化"></a>资源插件化</h2><p><strong>为什么：资源插件化减少apk包大小</strong></p>
<p>通过前面的资源加载查找流程分析，正常情况下应用只能访问到自己apk的资源，四大组件的插件化虽然能加载到插件里面的activity，但插件里面的资源没有被加载到应用内存里面。</p>
<p><strong>怎么做：</strong></p>
<p>资源初始化阶段反射方式多次调用AssetManager.addAssetPath(String path)方法，把所有插件的apk路径传递进去。</p>
<p>构建一个全局的超级Resource对象，在查找时把所有调用到Resource的地方替换成全局的超级Resource对象。</p>
<p>新插件加载后引起全局资源变化，重新替换已存在Context实例的Resource、AssetManager</p>
<h3 id="插件引用宿主的资源"><a href="#插件引用宿主的资源" class="headerlink" title="插件引用宿主的资源"></a>插件引用宿主的资源</h3><p>在插件化中，宿主不会直接使用到插件里面的资源，通常是插件共享宿主的资源。</p>
<p>在插件的资源打包任务（processResourcesTask）完成之后将宿主的R.txt文件合并到插件的R.txt文件中，再将合并后的R.txt转成R.java文件并替换插件的R.java文件，这样插件中的R文件就会包含宿主的资源。</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_10.png" alt="img"></p>
<h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><h5 id="资源ID冲突："><a href="#资源ID冲突：" class="headerlink" title="资源ID冲突："></a>资源ID冲突：</h5><p>插件和宿主打包apk是独立的，无法保证生成的资源ID值不重复</p>
<img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_11.png" alt="img" style="zoom: 50%;">

<p><strong>资源ID重复有什么影响？</strong></p>
<p>资源查找流程底层源码：AssetManager.getResTable –&gt; ResTable.getResource：</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_12.png" alt="img" style="zoom: 67%;"><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_13.png" alt="img" style="zoom: 67%;"></p>
<p>结论：查找资源时会优先返回后添加的插件资源，宿主的资源可能被插件覆盖</p>
<p><strong>解决办法：</strong></p>
<p>对插件的资源分区，修改插件的packageId与宿主区分</p>
<p>aapt1：修改aapt源码中生成资源id的逻辑、修改编译后的二进制资源文件</p>
<p>aapt2(AGP &gt;= 3.0.0默认开启)：执行命令时添加–package-id xx</p>
<blockquote>
<p>使用aapt2指定插件资源id的PP字段，需要buildToolsVersion &gt;= 28.0.0</p>
</blockquote>
<ul>
<li><blockquote>
<p>在buildTools28.0.0版本之前，只支持指定资源id PP字段在0x7f-0xff范围内，尴尬的是Android 8.0之前不支持&gt;0x7f的PP段资源。</p>
</blockquote>
</li>
<li><blockquote>
<p>buildTools28.0.0版本开始提供 –allow-reserved-package-id参数，可以指定0x02 -0x7e范围内的PP段资源。</p>
</blockquote>
</li>
</ul>
<p>–allow-reserved-package-id –package-id  xxxx</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_14.png" alt="img"><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_15.png" alt="img"></p>
<p><strong>mira实现：</strong>通过gradle插件收集packageId，添加aapt编译命令参数</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_16.png" alt="img"><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_17.png" alt="img" style="zoom:67%;"></p>
<h5 id="资源固定"><a href="#资源固定" class="headerlink" title="资源固定"></a>资源固定</h5><p>资源固定是为了使插件具备跨宿主版本的能力。</p>
<p>在打包插件时，会合并宿主当前版本的R文件，后续宿主包中有新增/删除资源时，宿主aapt编译生成的资源ID顺序改变，导致插件访问到错误的宿主资源</p>
<p><img src="/2020/12/23/%E6%8F%92%E4%BB%B6%E5%8C%96-Android%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90/image_18.png" alt="image-20210403214422582"></p>
<p>所以需要把依赖到宿主的资源写在public.xml中固定，确保每一个版本依赖的资源ID都不变。</p>
<h5 id="资源名称冲突"><a href="#资源名称冲突" class="headerlink" title="资源名称冲突"></a>资源名称冲突</h5><p><a href="http://www.autism-tl.cn/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/#more">Lite插件与宿主资源重复问题分析</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>十分钟了解Android依赖关系</title>
    <url>/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="依赖关系展示"><a href="#依赖关系展示" class="headerlink" title="依赖关系展示"></a>依赖关系展示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiDependenciesMetadata</span><br><span class="line">...</span><br><span class="line">debugCompileClasspath - Compile classpath for compilation &#39;debug&#39; (target  (androidJvm))</span><br><span class="line">...</span><br><span class="line">debugCompileOnly - Compile only dependencies for compilation &#39;debug&#39; (target  (androidJvm)).</span><br><span class="line">...</span><br><span class="line">releaseCompileClasspath - Compile classpath for compilation &#39;release&#39; (target  (androidJvm)).</span><br><span class="line">...</span><br><span class="line">implementation - Implementation only dependencies for &#39;main&#39; sources. (n)</span><br><span class="line">...</span><br><span class="line">releaseRuntimeClasspath - Runtime classpath of compilation &#39;release&#39; (target  (androidJvm)).</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>依赖关系的展示路径包含依赖方式(configuration)+编译变体的组合：</p>
<ol>
<li>依赖方式(可单独配置展示)：CompileClasspath编译时、RuntimeClasspath运行时、CompileOnly、RuntimeOnly、等</li>
</ol>
<p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_1.png" alt="img"></p>
<ol start="2">
<li>编译变体：Build Type+Product Flavor，没有flavor为debug、release、test等。如果有flavor则为toutiaoDebug、liteRelease等</li>
</ol>
<p>例如：debugCompileOnly、releaseCompileClasspath等</p>
<h2 id="查看依赖关系的方式"><a href="#查看依赖关系的方式" class="headerlink" title="查看依赖关系的方式"></a>查看依赖关系的方式</h2><h3 id="一、命令行："><a href="#一、命令行：" class="headerlink" title="一、命令行："></a>一、命令行：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;gradlew $&#123;module&#125;:dependencies</span><br></pre></td></tr></table></figure>
<p>列出该模块下所有第三方类库的依赖树组合</p>
<p>如果只想输入特定组合的依赖树，可以使用–configuration配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;仅输入debugCompileOnly的依赖关系</span><br><span class="line"></span><br><span class="line">.&#x2F;gradlew $&#123;module&#125;:dependencies --configuration debugCompileOnly </span><br></pre></td></tr></table></figure>


<h3 id="二、Gradle插件："><a href="#二、Gradle插件：" class="headerlink" title="二、Gradle插件："></a>二、Gradle插件：</h3><p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_2.png" alt="img"></p>
<p><strong>dependencies</strong>：与命令行操作一致，输出模块的所有依赖</p>
<p><strong>dependencyInsight</strong>：解释依赖树中的一个依赖如何被选择，为什么被选择(逆向打印依赖关系)。可用作”Could not resolve com.xxx:okhttp:{strictly 3.0.0}”版本号冲突问题的排查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;thread为第三方依赖库</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;图1 debugCompileOnly  CompileOnly依赖路径</span><br><span class="line"></span><br><span class="line">.&#x2F;gradlew comment:dependencyInsight --dependency thread --configuration debugCompileOnly</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;图2 debugCompileClasspath   编译期依赖路径</span><br><span class="line"></span><br><span class="line">.&#x2F;gradlew comment:dependencyInsight --dependency thread --configuration debugCompileClasspath</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_3.png" alt="img"></p>
<p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_4.png" alt="img"></p>
<h3 id="三、Gradle官方构建分析页面"><a href="#三、Gradle官方构建分析页面" class="headerlink" title="三、Gradle官方构建分析页面"></a>三、Gradle官方构建分析页面</h3><p>如果嫌弃命令行窗口查看依赖树不友好，或者需要查看整个工程项目的依赖树时，有一种方式可以到HTML网页查看依赖树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;gradlew build --scan</span><br></pre></td></tr></table></figure>
<p>在工程根目录输入这个命令后，会出现如下：</p>
<p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_5.png" alt="img"></p>
<p>输入yes后会在Gradle官方页面生成构建页面</p>
<p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_6.png" alt="img"></p>
<p>用任意邮箱登录后可更方便的查看整个项目的依赖关系</p>
<p><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_7.png" alt="img"><img src="/2021/03/26/%E5%8D%81%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3Android%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/image_8.png" alt="img"></p>
<h2 id="依赖关系分析"><a href="#依赖关系分析" class="headerlink" title="依赖关系分析"></a>依赖关系分析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--- androidx.recyclerview:recyclerview:1.0.0</span><br><span class="line">|    +--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    +--- androidx.core:core:1.0.0</span><br><span class="line">|    |    +--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    |    +--- androidx.collection:collection:1.0.0</span><br><span class="line">|    |    |    \--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    |    +--- androidx.lifecycle:lifecycle-runtime:2.0.0</span><br><span class="line">|    |    |    +--- androidx.lifecycle:lifecycle-common:2.0.0</span><br><span class="line">|    |    |    |    \--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    |    |    +--- androidx.arch.core:core-common:2.0.0</span><br><span class="line">|    |    |    |    \--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    |    |    \--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    |    \--- androidx.versionedparcelable:versionedparcelable:1.0.0</span><br><span class="line">|    |         +--- androidx.annotation:annotation:1.0.0</span><br><span class="line">|    |         \--- androidx.collection:collection:1.0.0 (*)</span><br><span class="line">|    \--- androidx.legacy:legacy-support-core-ui:1.0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p><strong>符号定义：</strong></p>
<ul>
<li>+- - - 是依赖分支库的开始。</li>
<li>| 标识还是在之前的依赖库中的依赖，显示它依赖的库。</li>
<li>- - - 是依赖库的末尾。</li>
<li>(*)意味着该库的进一步依赖关系不会显示，因为它们已经列在其他某个子依赖树中</li>
<li>-&gt;Gradle 发现多个依赖库都依赖到同一个库但是不同版本，强制转换版本，可体现源码依赖</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>插件与宿主资源名重复问题分析</title>
    <url>/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="问题背景："><a href="#问题背景：" class="headerlink" title="问题背景："></a>问题背景：</h3><ol>
<li>tt_ugc_business仓库ugc-view模块中直播头像相关的自定义View(UserAvatarLiveView)被多个非ugc业务方依赖，已经不适合放在ugc-view模块，所以计划迁移到更通用的Guadian仓库image模块</li>
<li>image模块是以flavor的形式在头条主端和lite端使用的，为了隔绝上层依赖独立仓库模块时需要配置flavor，独立仓库模块依赖image都是以<strong>complieOnly</strong>的形式。</li>
</ol>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_1.png" alt="img"></p>
<ol start="3">
<li>ugc-view模块在xml文件中使用了UserAvatarLiveView类的自定义属性，compileOnly的依赖方式会导致image模块的资源文件无法引用从而打aar失败，所以ugc-view模块中用到image的资源被迫在模块中重新声明一遍才能打包通过。</li>
</ol>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_2.png" alt="img"></p>
<p><strong>最终结果：ugc-view和image模块里都存在UserAvatarLiveView类自定义属性的声明（complieOnly的弊端）</strong></p>
<h3 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h3><p>迁移代码合入主端ttmain之后表现正常。</p>
<p>lite端同步升级ugc-view和image模块版本号之后，发现直播头像外框大小异常</p>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_3.png" alt="img"><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_4.png" alt="img"></p>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ol>
<li>找到对应宿主的类UserAvatarLiveView断点分析，dubug获取的外框属性值取到的是默认值76dp。</li>
</ol>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_5.png" alt="img"></p>
<p>猜测是自定义属性值未生效导致</p>
<p>这个现象就比较奇怪了，同样的代码主端没问题，lite却拿不到对应的自定义属性值（如何去分析）</p>
<ol start="2">
<li>排查发现UserAvatarLiveView类的attr的声明在ugc-view和image两个aar模块中都存在，而image模块是打包在lite宿主中的，ugc-view是打包在newugc插件中的，会不会是attr资源id没对应上呢</li>
</ol>
<ol start="3">
<li>分析宿主apk和插件apk中是否存在对应的属性id</li>
</ol>
<p>宿主的R文件(1.2w行)和resources.arcs文件</p>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_6.png" alt="img"><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_7.png" alt="img"></p>
<p>newugc插件的R文件(1.6w行)和resources.arcs文件</p>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_8.png" alt="img"><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_9.png" alt="img"></p>
<p>可以看到宿主和插件中都存在对应属性的定义，并且插件中的属性id会被加上插件固定的前缀。</p>
<p>Mira框架打插件时会合并插件和宿主的R文件，资源名称冲突的非id类型资源会使用插件里的</p>
<p>如果在ugc-view模块的xml中设置自定义属性，属性字符串animation_live_circle_height会索引到插件的资源ID(0x36030004)</p>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_10.png" alt="img"></p>
<p>而插件中的ugc-view模块代码在使用宿主image模块的UserAvatarLiveView类时会根据宿主的资源ID(0x7f010134)去查找，由于属性ID(0x7f010134)并未被赋值，所以就使用了默认值76dp。</p>
<p><img src="/2020/12/22/%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AE%BF%E4%B8%BB%E8%B5%84%E6%BA%90%E5%90%8D%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/image_11.png" alt="img"></p>
<h3 id="解决-amp-总结"><a href="#解决-amp-总结" class="headerlink" title="解决&amp;总结"></a>解决&amp;总结</h3><ul>
<li>临时的解决方法是把ugc-view模块中xml文件用到的自定义属性全部删除，改成用java代码去设置属性值。这样就不存在属性声明重复导致的问题了。</li>
<li>问题的难点在于排查分析原因。该bug出现的前提条件较多，插件与宿主资源重复的场景也比较小，属于非常规case，如果没有正确的思路指引，排查起来会比较耗费精力。</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
